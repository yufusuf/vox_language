Grammar:

Rule 0     S' -> program
Rule 1     program -> V F S
Rule 2     V -> empty
Rule 3     V -> V varDecl
Rule 4     varDecl -> VAR ID ASSIGN [ Vexprs ] ;
Rule 5     varDecl -> VAR ID ASSIGN expr ;
Rule 6     varDecl -> VAR ID ;
Rule 7     Vexprs -> expr
Rule 8     Vexprs -> Vexprs , expr
Rule 9     F -> empty
Rule 10    F -> F funDecl
Rule 11    funDecl -> FUN ID ( parameters ) block
Rule 12    parameters -> P
Rule 13    parameters -> empty
Rule 14    P -> P , ID
Rule 15    P -> ID
Rule 16    block -> { V S }
Rule 17    S -> S free_stmt
Rule 18    S -> empty
Rule 19    stmt -> block
Rule 20    stmt -> free_stmt
Rule 21    free_stmt -> compound_stmt
Rule 22    free_stmt -> simple_stmt ;
Rule 23    asgn_stmt -> ID [ aexpr ] ASSIGN expr
Rule 24    asgn_stmt -> ID ASSIGN expr
Rule 25    simple_stmt -> return_stmt
Rule 26    simple_stmt -> print_stmt
Rule 27    simple_stmt -> asgn_stmt
Rule 28    print_stmt -> PRINT expr
Rule 29    return_stmt -> RETURN expr
Rule 30    compound_stmt -> for_stmt
Rule 31    compound_stmt -> while_stmt
Rule 32    compound_stmt -> if_stmt
Rule 33    if_stmt -> IF lexpr stmt ELSE stmt
Rule 34    if_stmt -> IF lexpr stmt
Rule 35    while_stmt -> WHILE lexpr stmt
Rule 36    for_stmt -> FOR ( for_asgn ; for_lexpr ; for_asgn ) stmt
Rule 37    for_asgn -> empty
Rule 38    for_asgn -> asgn_stmt
Rule 39    for_lexpr -> empty
Rule 40    for_lexpr -> lexpr
Rule 41    expr -> aexpr
Rule 42    expr -> sexpr
Rule 43    expr -> lexpr
Rule 44    sexpr -> STRING
Rule 45    aexpr -> term
Rule 46    aexpr -> aexpr MINUS term
Rule 47    aexpr -> aexpr PLUS term
Rule 48    term -> fact
Rule 49    term -> term TIMES fact
Rule 50    term -> term DIVIDE fact
Rule 51    fact -> ID [ aexpr ]
Rule 52    fact -> ID
Rule 53    fact -> ( aexpr )
Rule 54    fact -> NUMBER
Rule 55    fact -> call
Rule 56    fact -> MINUS fact
Rule 57    cexpr -> aexpr LE aexpr
Rule 58    cexpr -> aexpr LT aexpr
Rule 59    cexpr -> aexpr GE aexpr
Rule 60    cexpr -> aexpr GT aexpr
Rule 61    cexpr -> aexpr NE aexpr
Rule 62    cexpr -> aexpr EQ aexpr
Rule 63    lexpr -> lterm
Rule 64    lexpr -> lexpr OR lterm
Rule 65    lterm -> lfact
Rule 66    lterm -> lterm AND lfact
Rule 67    lfact -> FALSE
Rule 68    lfact -> TRUE
Rule 69    lfact -> NOT lfact
Rule 70    lfact -> # ID [ aexpr ]
Rule 71    lfact -> # ID
Rule 72    lfact -> ( lexpr )
Rule 73    lfact -> # call
Rule 74    lfact -> cexpr
Rule 75    call -> ID ( args )
Rule 76    args -> A
Rule 77    args -> empty
Rule 78    A -> A , expr
Rule 79    A -> expr
Rule 80    empty -> <empty>

Terminals, with rules where they appear:

#                    : 70 71 73
(                    : 11 36 53 72 75
)                    : 11 36 53 72 75
,                    : 8 14 78
;                    : 4 5 6 22 36 36
AND                  : 66
ASSIGN               : 4 5 23 24
DIVIDE               : 50
ELSE                 : 33
EQ                   : 62
FALSE                : 67
FOR                  : 36
FUN                  : 11
GE                   : 59
GT                   : 60
ID                   : 4 5 6 11 14 15 23 24 51 52 70 71 75
IF                   : 33 34
LE                   : 57
LT                   : 58
MINUS                : 46 56
NE                   : 61
NOT                  : 69
NUMBER               : 54
OR                   : 64
PLUS                 : 47
PRINT                : 28
RETURN               : 29
STRING               : 44
TIMES                : 49
TRUE                 : 68
VAR                  : 4 5 6
WHILE                : 35
[                    : 4 23 51 70
]                    : 4 23 51 70
error                : 
{                    : 16
}                    : 16

Nonterminals, with rules where they appear:

A                    : 76 78
F                    : 1 10
P                    : 12 14
S                    : 1 16 17
V                    : 1 3 16
Vexprs               : 4 8
aexpr                : 23 41 46 47 51 53 57 57 58 58 59 59 60 60 61 61 62 62 70
args                 : 75
asgn_stmt            : 27 38
block                : 11 19
call                 : 55 73
cexpr                : 74
compound_stmt        : 21
empty                : 2 9 13 18 37 39 77
expr                 : 5 7 8 23 24 28 29 78 79
fact                 : 48 49 50 56
for_asgn             : 36 36
for_lexpr            : 36
for_stmt             : 30
free_stmt            : 17 20
funDecl              : 10
if_stmt              : 32
lexpr                : 33 34 35 40 43 64 72
lfact                : 65 66 69
lterm                : 63 64 66
parameters           : 11
print_stmt           : 26
program              : 0
return_stmt          : 25
sexpr                : 42
simple_stmt          : 22
stmt                 : 33 33 34 35 36
term                 : 45 46 47 49 50
varDecl              : 3
while_stmt           : 31


state 0

    (0) S' -> . program
    (1) program -> . V F S
    (2) V -> . empty
    (3) V -> . V varDecl
    (80) empty -> .
    VAR             reduce using rule 80 (empty -> .)
    FUN             reduce using rule 80 (empty -> .)
    FOR             reduce using rule 80 (empty -> .)
    WHILE           reduce using rule 80 (empty -> .)
    IF              reduce using rule 80 (empty -> .)
    RETURN          reduce using rule 80 (empty -> .)
    PRINT           reduce using rule 80 (empty -> .)
    ID              reduce using rule 80 (empty -> .)
    $end            reduce using rule 80 (empty -> .)

    program                        shift and go to state 1
    V                              shift and go to state 2
    empty                          shift and go to state 3

state 1

    (0) S' -> program .


state 2

    (1) program -> V . F S
    (3) V -> V . varDecl
    (9) F -> . empty
    (10) F -> . F funDecl
    (4) varDecl -> . VAR ID ASSIGN [ Vexprs ] ;
    (5) varDecl -> . VAR ID ASSIGN expr ;
    (6) varDecl -> . VAR ID ;
    (80) empty -> .
    VAR             shift and go to state 7
    FUN             reduce using rule 80 (empty -> .)
    FOR             reduce using rule 80 (empty -> .)
    WHILE           reduce using rule 80 (empty -> .)
    IF              reduce using rule 80 (empty -> .)
    RETURN          reduce using rule 80 (empty -> .)
    PRINT           reduce using rule 80 (empty -> .)
    ID              reduce using rule 80 (empty -> .)
    $end            reduce using rule 80 (empty -> .)

    F                              shift and go to state 4
    varDecl                        shift and go to state 5
    empty                          shift and go to state 6

state 3

    (2) V -> empty .
    VAR             reduce using rule 2 (V -> empty .)
    FUN             reduce using rule 2 (V -> empty .)
    FOR             reduce using rule 2 (V -> empty .)
    WHILE           reduce using rule 2 (V -> empty .)
    IF              reduce using rule 2 (V -> empty .)
    RETURN          reduce using rule 2 (V -> empty .)
    PRINT           reduce using rule 2 (V -> empty .)
    ID              reduce using rule 2 (V -> empty .)
    $end            reduce using rule 2 (V -> empty .)
    }               reduce using rule 2 (V -> empty .)


state 4

    (1) program -> V F . S
    (10) F -> F . funDecl
    (17) S -> . S free_stmt
    (18) S -> . empty
    (11) funDecl -> . FUN ID ( parameters ) block
    (80) empty -> .
    FUN             shift and go to state 11
    FOR             reduce using rule 80 (empty -> .)
    WHILE           reduce using rule 80 (empty -> .)
    IF              reduce using rule 80 (empty -> .)
    RETURN          reduce using rule 80 (empty -> .)
    PRINT           reduce using rule 80 (empty -> .)
    ID              reduce using rule 80 (empty -> .)
    $end            reduce using rule 80 (empty -> .)

    S                              shift and go to state 8
    funDecl                        shift and go to state 9
    empty                          shift and go to state 10

state 5

    (3) V -> V varDecl .
    VAR             reduce using rule 3 (V -> V varDecl .)
    FUN             reduce using rule 3 (V -> V varDecl .)
    FOR             reduce using rule 3 (V -> V varDecl .)
    WHILE           reduce using rule 3 (V -> V varDecl .)
    IF              reduce using rule 3 (V -> V varDecl .)
    RETURN          reduce using rule 3 (V -> V varDecl .)
    PRINT           reduce using rule 3 (V -> V varDecl .)
    ID              reduce using rule 3 (V -> V varDecl .)
    $end            reduce using rule 3 (V -> V varDecl .)
    }               reduce using rule 3 (V -> V varDecl .)


state 6

    (9) F -> empty .
    FUN             reduce using rule 9 (F -> empty .)
    FOR             reduce using rule 9 (F -> empty .)
    WHILE           reduce using rule 9 (F -> empty .)
    IF              reduce using rule 9 (F -> empty .)
    RETURN          reduce using rule 9 (F -> empty .)
    PRINT           reduce using rule 9 (F -> empty .)
    ID              reduce using rule 9 (F -> empty .)
    $end            reduce using rule 9 (F -> empty .)


state 7

    (4) varDecl -> VAR . ID ASSIGN [ Vexprs ] ;
    (5) varDecl -> VAR . ID ASSIGN expr ;
    (6) varDecl -> VAR . ID ;
    ID              shift and go to state 12


state 8

    (1) program -> V F S .
    (17) S -> S . free_stmt
    (21) free_stmt -> . compound_stmt
    (22) free_stmt -> . simple_stmt ;
    (30) compound_stmt -> . for_stmt
    (31) compound_stmt -> . while_stmt
    (32) compound_stmt -> . if_stmt
    (25) simple_stmt -> . return_stmt
    (26) simple_stmt -> . print_stmt
    (27) simple_stmt -> . asgn_stmt
    (36) for_stmt -> . FOR ( for_asgn ; for_lexpr ; for_asgn ) stmt
    (35) while_stmt -> . WHILE lexpr stmt
    (33) if_stmt -> . IF lexpr stmt ELSE stmt
    (34) if_stmt -> . IF lexpr stmt
    (29) return_stmt -> . RETURN expr
    (28) print_stmt -> . PRINT expr
    (23) asgn_stmt -> . ID [ aexpr ] ASSIGN expr
    (24) asgn_stmt -> . ID ASSIGN expr
    $end            reduce using rule 1 (program -> V F S .)
    FOR             shift and go to state 22
    WHILE           shift and go to state 23
    IF              shift and go to state 24
    RETURN          shift and go to state 25
    PRINT           shift and go to state 26
    ID              shift and go to state 27

    free_stmt                      shift and go to state 13
    compound_stmt                  shift and go to state 14
    simple_stmt                    shift and go to state 15
    for_stmt                       shift and go to state 16
    while_stmt                     shift and go to state 17
    if_stmt                        shift and go to state 18
    return_stmt                    shift and go to state 19
    print_stmt                     shift and go to state 20
    asgn_stmt                      shift and go to state 21

state 9

    (10) F -> F funDecl .
    FUN             reduce using rule 10 (F -> F funDecl .)
    FOR             reduce using rule 10 (F -> F funDecl .)
    WHILE           reduce using rule 10 (F -> F funDecl .)
    IF              reduce using rule 10 (F -> F funDecl .)
    RETURN          reduce using rule 10 (F -> F funDecl .)
    PRINT           reduce using rule 10 (F -> F funDecl .)
    ID              reduce using rule 10 (F -> F funDecl .)
    $end            reduce using rule 10 (F -> F funDecl .)


state 10

    (18) S -> empty .
    FOR             reduce using rule 18 (S -> empty .)
    WHILE           reduce using rule 18 (S -> empty .)
    IF              reduce using rule 18 (S -> empty .)
    RETURN          reduce using rule 18 (S -> empty .)
    PRINT           reduce using rule 18 (S -> empty .)
    ID              reduce using rule 18 (S -> empty .)
    $end            reduce using rule 18 (S -> empty .)
    }               reduce using rule 18 (S -> empty .)


state 11

    (11) funDecl -> FUN . ID ( parameters ) block
    ID              shift and go to state 28


state 12

    (4) varDecl -> VAR ID . ASSIGN [ Vexprs ] ;
    (5) varDecl -> VAR ID . ASSIGN expr ;
    (6) varDecl -> VAR ID . ;
    ASSIGN          shift and go to state 29
    ;               shift and go to state 30


state 13

    (17) S -> S free_stmt .
    FOR             reduce using rule 17 (S -> S free_stmt .)
    WHILE           reduce using rule 17 (S -> S free_stmt .)
    IF              reduce using rule 17 (S -> S free_stmt .)
    RETURN          reduce using rule 17 (S -> S free_stmt .)
    PRINT           reduce using rule 17 (S -> S free_stmt .)
    ID              reduce using rule 17 (S -> S free_stmt .)
    $end            reduce using rule 17 (S -> S free_stmt .)
    }               reduce using rule 17 (S -> S free_stmt .)


state 14

    (21) free_stmt -> compound_stmt .
    FOR             reduce using rule 21 (free_stmt -> compound_stmt .)
    WHILE           reduce using rule 21 (free_stmt -> compound_stmt .)
    IF              reduce using rule 21 (free_stmt -> compound_stmt .)
    RETURN          reduce using rule 21 (free_stmt -> compound_stmt .)
    PRINT           reduce using rule 21 (free_stmt -> compound_stmt .)
    ID              reduce using rule 21 (free_stmt -> compound_stmt .)
    $end            reduce using rule 21 (free_stmt -> compound_stmt .)
    ELSE            reduce using rule 21 (free_stmt -> compound_stmt .)
    }               reduce using rule 21 (free_stmt -> compound_stmt .)


state 15

    (22) free_stmt -> simple_stmt . ;
    ;               shift and go to state 31


state 16

    (30) compound_stmt -> for_stmt .
    FOR             reduce using rule 30 (compound_stmt -> for_stmt .)
    WHILE           reduce using rule 30 (compound_stmt -> for_stmt .)
    IF              reduce using rule 30 (compound_stmt -> for_stmt .)
    RETURN          reduce using rule 30 (compound_stmt -> for_stmt .)
    PRINT           reduce using rule 30 (compound_stmt -> for_stmt .)
    ID              reduce using rule 30 (compound_stmt -> for_stmt .)
    $end            reduce using rule 30 (compound_stmt -> for_stmt .)
    ELSE            reduce using rule 30 (compound_stmt -> for_stmt .)
    }               reduce using rule 30 (compound_stmt -> for_stmt .)


state 17

    (31) compound_stmt -> while_stmt .
    FOR             reduce using rule 31 (compound_stmt -> while_stmt .)
    WHILE           reduce using rule 31 (compound_stmt -> while_stmt .)
    IF              reduce using rule 31 (compound_stmt -> while_stmt .)
    RETURN          reduce using rule 31 (compound_stmt -> while_stmt .)
    PRINT           reduce using rule 31 (compound_stmt -> while_stmt .)
    ID              reduce using rule 31 (compound_stmt -> while_stmt .)
    $end            reduce using rule 31 (compound_stmt -> while_stmt .)
    ELSE            reduce using rule 31 (compound_stmt -> while_stmt .)
    }               reduce using rule 31 (compound_stmt -> while_stmt .)


state 18

    (32) compound_stmt -> if_stmt .
    FOR             reduce using rule 32 (compound_stmt -> if_stmt .)
    WHILE           reduce using rule 32 (compound_stmt -> if_stmt .)
    IF              reduce using rule 32 (compound_stmt -> if_stmt .)
    RETURN          reduce using rule 32 (compound_stmt -> if_stmt .)
    PRINT           reduce using rule 32 (compound_stmt -> if_stmt .)
    ID              reduce using rule 32 (compound_stmt -> if_stmt .)
    $end            reduce using rule 32 (compound_stmt -> if_stmt .)
    ELSE            reduce using rule 32 (compound_stmt -> if_stmt .)
    }               reduce using rule 32 (compound_stmt -> if_stmt .)


state 19

    (25) simple_stmt -> return_stmt .
    ;               reduce using rule 25 (simple_stmt -> return_stmt .)


state 20

    (26) simple_stmt -> print_stmt .
    ;               reduce using rule 26 (simple_stmt -> print_stmt .)


state 21

    (27) simple_stmt -> asgn_stmt .
    ;               reduce using rule 27 (simple_stmt -> asgn_stmt .)


state 22

    (36) for_stmt -> FOR . ( for_asgn ; for_lexpr ; for_asgn ) stmt
    (               shift and go to state 32


state 23

    (35) while_stmt -> WHILE . lexpr stmt
    (63) lexpr -> . lterm
    (64) lexpr -> . lexpr OR lterm
    (65) lterm -> . lfact
    (66) lterm -> . lterm AND lfact
    (67) lfact -> . FALSE
    (68) lfact -> . TRUE
    (69) lfact -> . NOT lfact
    (70) lfact -> . # ID [ aexpr ]
    (71) lfact -> . # ID
    (72) lfact -> . ( lexpr )
    (73) lfact -> . # call
    (74) lfact -> . cexpr
    (57) cexpr -> . aexpr LE aexpr
    (58) cexpr -> . aexpr LT aexpr
    (59) cexpr -> . aexpr GE aexpr
    (60) cexpr -> . aexpr GT aexpr
    (61) cexpr -> . aexpr NE aexpr
    (62) cexpr -> . aexpr EQ aexpr
    (45) aexpr -> . term
    (46) aexpr -> . aexpr MINUS term
    (47) aexpr -> . aexpr PLUS term
    (48) term -> . fact
    (49) term -> . term TIMES fact
    (50) term -> . term DIVIDE fact
    (51) fact -> . ID [ aexpr ]
    (52) fact -> . ID
    (53) fact -> . ( aexpr )
    (54) fact -> . NUMBER
    (55) fact -> . call
    (56) fact -> . MINUS fact
    (75) call -> . ID ( args )
    FALSE           shift and go to state 36
    TRUE            shift and go to state 37
    NOT             shift and go to state 38
    #               shift and go to state 39
    (               shift and go to state 42
    ID              shift and go to state 40
    NUMBER          shift and go to state 48
    MINUS           shift and go to state 46

    lexpr                          shift and go to state 33
    lterm                          shift and go to state 34
    lfact                          shift and go to state 35
    aexpr                          shift and go to state 41
    call                           shift and go to state 43
    cexpr                          shift and go to state 44
    term                           shift and go to state 45
    fact                           shift and go to state 47

state 24

    (33) if_stmt -> IF . lexpr stmt ELSE stmt
    (34) if_stmt -> IF . lexpr stmt
    (63) lexpr -> . lterm
    (64) lexpr -> . lexpr OR lterm
    (65) lterm -> . lfact
    (66) lterm -> . lterm AND lfact
    (67) lfact -> . FALSE
    (68) lfact -> . TRUE
    (69) lfact -> . NOT lfact
    (70) lfact -> . # ID [ aexpr ]
    (71) lfact -> . # ID
    (72) lfact -> . ( lexpr )
    (73) lfact -> . # call
    (74) lfact -> . cexpr
    (57) cexpr -> . aexpr LE aexpr
    (58) cexpr -> . aexpr LT aexpr
    (59) cexpr -> . aexpr GE aexpr
    (60) cexpr -> . aexpr GT aexpr
    (61) cexpr -> . aexpr NE aexpr
    (62) cexpr -> . aexpr EQ aexpr
    (45) aexpr -> . term
    (46) aexpr -> . aexpr MINUS term
    (47) aexpr -> . aexpr PLUS term
    (48) term -> . fact
    (49) term -> . term TIMES fact
    (50) term -> . term DIVIDE fact
    (51) fact -> . ID [ aexpr ]
    (52) fact -> . ID
    (53) fact -> . ( aexpr )
    (54) fact -> . NUMBER
    (55) fact -> . call
    (56) fact -> . MINUS fact
    (75) call -> . ID ( args )
    FALSE           shift and go to state 36
    TRUE            shift and go to state 37
    NOT             shift and go to state 38
    #               shift and go to state 39
    (               shift and go to state 42
    ID              shift and go to state 40
    NUMBER          shift and go to state 48
    MINUS           shift and go to state 46

    lexpr                          shift and go to state 49
    lterm                          shift and go to state 34
    lfact                          shift and go to state 35
    aexpr                          shift and go to state 41
    call                           shift and go to state 43
    cexpr                          shift and go to state 44
    term                           shift and go to state 45
    fact                           shift and go to state 47

state 25

    (29) return_stmt -> RETURN . expr
    (41) expr -> . aexpr
    (42) expr -> . sexpr
    (43) expr -> . lexpr
    (45) aexpr -> . term
    (46) aexpr -> . aexpr MINUS term
    (47) aexpr -> . aexpr PLUS term
    (44) sexpr -> . STRING
    (63) lexpr -> . lterm
    (64) lexpr -> . lexpr OR lterm
    (48) term -> . fact
    (49) term -> . term TIMES fact
    (50) term -> . term DIVIDE fact
    (65) lterm -> . lfact
    (66) lterm -> . lterm AND lfact
    (51) fact -> . ID [ aexpr ]
    (52) fact -> . ID
    (53) fact -> . ( aexpr )
    (54) fact -> . NUMBER
    (55) fact -> . call
    (56) fact -> . MINUS fact
    (67) lfact -> . FALSE
    (68) lfact -> . TRUE
    (69) lfact -> . NOT lfact
    (70) lfact -> . # ID [ aexpr ]
    (71) lfact -> . # ID
    (72) lfact -> . ( lexpr )
    (73) lfact -> . # call
    (74) lfact -> . cexpr
    (75) call -> . ID ( args )
    (57) cexpr -> . aexpr LE aexpr
    (58) cexpr -> . aexpr LT aexpr
    (59) cexpr -> . aexpr GE aexpr
    (60) cexpr -> . aexpr GT aexpr
    (61) cexpr -> . aexpr NE aexpr
    (62) cexpr -> . aexpr EQ aexpr
    STRING          shift and go to state 54
    ID              shift and go to state 40
    (               shift and go to state 55
    NUMBER          shift and go to state 48
    MINUS           shift and go to state 46
    FALSE           shift and go to state 36
    TRUE            shift and go to state 37
    NOT             shift and go to state 38
    #               shift and go to state 39

    expr                           shift and go to state 50
    aexpr                          shift and go to state 51
    sexpr                          shift and go to state 52
    lexpr                          shift and go to state 53
    term                           shift and go to state 45
    lterm                          shift and go to state 34
    fact                           shift and go to state 47
    lfact                          shift and go to state 35
    call                           shift and go to state 43
    cexpr                          shift and go to state 44

state 26

    (28) print_stmt -> PRINT . expr
    (41) expr -> . aexpr
    (42) expr -> . sexpr
    (43) expr -> . lexpr
    (45) aexpr -> . term
    (46) aexpr -> . aexpr MINUS term
    (47) aexpr -> . aexpr PLUS term
    (44) sexpr -> . STRING
    (63) lexpr -> . lterm
    (64) lexpr -> . lexpr OR lterm
    (48) term -> . fact
    (49) term -> . term TIMES fact
    (50) term -> . term DIVIDE fact
    (65) lterm -> . lfact
    (66) lterm -> . lterm AND lfact
    (51) fact -> . ID [ aexpr ]
    (52) fact -> . ID
    (53) fact -> . ( aexpr )
    (54) fact -> . NUMBER
    (55) fact -> . call
    (56) fact -> . MINUS fact
    (67) lfact -> . FALSE
    (68) lfact -> . TRUE
    (69) lfact -> . NOT lfact
    (70) lfact -> . # ID [ aexpr ]
    (71) lfact -> . # ID
    (72) lfact -> . ( lexpr )
    (73) lfact -> . # call
    (74) lfact -> . cexpr
    (75) call -> . ID ( args )
    (57) cexpr -> . aexpr LE aexpr
    (58) cexpr -> . aexpr LT aexpr
    (59) cexpr -> . aexpr GE aexpr
    (60) cexpr -> . aexpr GT aexpr
    (61) cexpr -> . aexpr NE aexpr
    (62) cexpr -> . aexpr EQ aexpr
    STRING          shift and go to state 54
    ID              shift and go to state 40
    (               shift and go to state 55
    NUMBER          shift and go to state 48
    MINUS           shift and go to state 46
    FALSE           shift and go to state 36
    TRUE            shift and go to state 37
    NOT             shift and go to state 38
    #               shift and go to state 39

    expr                           shift and go to state 56
    aexpr                          shift and go to state 51
    sexpr                          shift and go to state 52
    lexpr                          shift and go to state 53
    term                           shift and go to state 45
    lterm                          shift and go to state 34
    fact                           shift and go to state 47
    lfact                          shift and go to state 35
    call                           shift and go to state 43
    cexpr                          shift and go to state 44

state 27

    (23) asgn_stmt -> ID . [ aexpr ] ASSIGN expr
    (24) asgn_stmt -> ID . ASSIGN expr
    [               shift and go to state 57
    ASSIGN          shift and go to state 58


state 28

    (11) funDecl -> FUN ID . ( parameters ) block
    (               shift and go to state 59


state 29

    (4) varDecl -> VAR ID ASSIGN . [ Vexprs ] ;
    (5) varDecl -> VAR ID ASSIGN . expr ;
    (41) expr -> . aexpr
    (42) expr -> . sexpr
    (43) expr -> . lexpr
    (45) aexpr -> . term
    (46) aexpr -> . aexpr MINUS term
    (47) aexpr -> . aexpr PLUS term
    (44) sexpr -> . STRING
    (63) lexpr -> . lterm
    (64) lexpr -> . lexpr OR lterm
    (48) term -> . fact
    (49) term -> . term TIMES fact
    (50) term -> . term DIVIDE fact
    (65) lterm -> . lfact
    (66) lterm -> . lterm AND lfact
    (51) fact -> . ID [ aexpr ]
    (52) fact -> . ID
    (53) fact -> . ( aexpr )
    (54) fact -> . NUMBER
    (55) fact -> . call
    (56) fact -> . MINUS fact
    (67) lfact -> . FALSE
    (68) lfact -> . TRUE
    (69) lfact -> . NOT lfact
    (70) lfact -> . # ID [ aexpr ]
    (71) lfact -> . # ID
    (72) lfact -> . ( lexpr )
    (73) lfact -> . # call
    (74) lfact -> . cexpr
    (75) call -> . ID ( args )
    (57) cexpr -> . aexpr LE aexpr
    (58) cexpr -> . aexpr LT aexpr
    (59) cexpr -> . aexpr GE aexpr
    (60) cexpr -> . aexpr GT aexpr
    (61) cexpr -> . aexpr NE aexpr
    (62) cexpr -> . aexpr EQ aexpr
    [               shift and go to state 60
    STRING          shift and go to state 54
    ID              shift and go to state 40
    (               shift and go to state 55
    NUMBER          shift and go to state 48
    MINUS           shift and go to state 46
    FALSE           shift and go to state 36
    TRUE            shift and go to state 37
    NOT             shift and go to state 38
    #               shift and go to state 39

    expr                           shift and go to state 61
    aexpr                          shift and go to state 51
    sexpr                          shift and go to state 52
    lexpr                          shift and go to state 53
    term                           shift and go to state 45
    lterm                          shift and go to state 34
    fact                           shift and go to state 47
    lfact                          shift and go to state 35
    call                           shift and go to state 43
    cexpr                          shift and go to state 44

state 30

    (6) varDecl -> VAR ID ; .
    VAR             reduce using rule 6 (varDecl -> VAR ID ; .)
    FUN             reduce using rule 6 (varDecl -> VAR ID ; .)
    FOR             reduce using rule 6 (varDecl -> VAR ID ; .)
    WHILE           reduce using rule 6 (varDecl -> VAR ID ; .)
    IF              reduce using rule 6 (varDecl -> VAR ID ; .)
    RETURN          reduce using rule 6 (varDecl -> VAR ID ; .)
    PRINT           reduce using rule 6 (varDecl -> VAR ID ; .)
    ID              reduce using rule 6 (varDecl -> VAR ID ; .)
    $end            reduce using rule 6 (varDecl -> VAR ID ; .)
    }               reduce using rule 6 (varDecl -> VAR ID ; .)


state 31

    (22) free_stmt -> simple_stmt ; .
    FOR             reduce using rule 22 (free_stmt -> simple_stmt ; .)
    WHILE           reduce using rule 22 (free_stmt -> simple_stmt ; .)
    IF              reduce using rule 22 (free_stmt -> simple_stmt ; .)
    RETURN          reduce using rule 22 (free_stmt -> simple_stmt ; .)
    PRINT           reduce using rule 22 (free_stmt -> simple_stmt ; .)
    ID              reduce using rule 22 (free_stmt -> simple_stmt ; .)
    $end            reduce using rule 22 (free_stmt -> simple_stmt ; .)
    ELSE            reduce using rule 22 (free_stmt -> simple_stmt ; .)
    }               reduce using rule 22 (free_stmt -> simple_stmt ; .)


state 32

    (36) for_stmt -> FOR ( . for_asgn ; for_lexpr ; for_asgn ) stmt
    (37) for_asgn -> . empty
    (38) for_asgn -> . asgn_stmt
    (80) empty -> .
    (23) asgn_stmt -> . ID [ aexpr ] ASSIGN expr
    (24) asgn_stmt -> . ID ASSIGN expr
    ;               reduce using rule 80 (empty -> .)
    ID              shift and go to state 27

    for_asgn                       shift and go to state 62
    empty                          shift and go to state 63
    asgn_stmt                      shift and go to state 64

state 33

    (35) while_stmt -> WHILE lexpr . stmt
    (64) lexpr -> lexpr . OR lterm
    (19) stmt -> . block
    (20) stmt -> . free_stmt
    (16) block -> . { V S }
    (21) free_stmt -> . compound_stmt
    (22) free_stmt -> . simple_stmt ;
    (30) compound_stmt -> . for_stmt
    (31) compound_stmt -> . while_stmt
    (32) compound_stmt -> . if_stmt
    (25) simple_stmt -> . return_stmt
    (26) simple_stmt -> . print_stmt
    (27) simple_stmt -> . asgn_stmt
    (36) for_stmt -> . FOR ( for_asgn ; for_lexpr ; for_asgn ) stmt
    (35) while_stmt -> . WHILE lexpr stmt
    (33) if_stmt -> . IF lexpr stmt ELSE stmt
    (34) if_stmt -> . IF lexpr stmt
    (29) return_stmt -> . RETURN expr
    (28) print_stmt -> . PRINT expr
    (23) asgn_stmt -> . ID [ aexpr ] ASSIGN expr
    (24) asgn_stmt -> . ID ASSIGN expr
    OR              shift and go to state 66
    {               shift and go to state 69
    FOR             shift and go to state 22
    WHILE           shift and go to state 23
    IF              shift and go to state 24
    RETURN          shift and go to state 25
    PRINT           shift and go to state 26
    ID              shift and go to state 27

    stmt                           shift and go to state 65
    block                          shift and go to state 67
    free_stmt                      shift and go to state 68
    compound_stmt                  shift and go to state 14
    simple_stmt                    shift and go to state 15
    for_stmt                       shift and go to state 16
    while_stmt                     shift and go to state 17
    if_stmt                        shift and go to state 18
    return_stmt                    shift and go to state 19
    print_stmt                     shift and go to state 20
    asgn_stmt                      shift and go to state 21

state 34

    (63) lexpr -> lterm .
    (66) lterm -> lterm . AND lfact
    OR              reduce using rule 63 (lexpr -> lterm .)
    {               reduce using rule 63 (lexpr -> lterm .)
    FOR             reduce using rule 63 (lexpr -> lterm .)
    WHILE           reduce using rule 63 (lexpr -> lterm .)
    IF              reduce using rule 63 (lexpr -> lterm .)
    RETURN          reduce using rule 63 (lexpr -> lterm .)
    PRINT           reduce using rule 63 (lexpr -> lterm .)
    ID              reduce using rule 63 (lexpr -> lterm .)
    ;               reduce using rule 63 (lexpr -> lterm .)
    )               reduce using rule 63 (lexpr -> lterm .)
    ]               reduce using rule 63 (lexpr -> lterm .)
    ,               reduce using rule 63 (lexpr -> lterm .)
    AND             shift and go to state 70


state 35

    (65) lterm -> lfact .
    AND             reduce using rule 65 (lterm -> lfact .)
    OR              reduce using rule 65 (lterm -> lfact .)
    {               reduce using rule 65 (lterm -> lfact .)
    FOR             reduce using rule 65 (lterm -> lfact .)
    WHILE           reduce using rule 65 (lterm -> lfact .)
    IF              reduce using rule 65 (lterm -> lfact .)
    RETURN          reduce using rule 65 (lterm -> lfact .)
    PRINT           reduce using rule 65 (lterm -> lfact .)
    ID              reduce using rule 65 (lterm -> lfact .)
    ;               reduce using rule 65 (lterm -> lfact .)
    )               reduce using rule 65 (lterm -> lfact .)
    ]               reduce using rule 65 (lterm -> lfact .)
    ,               reduce using rule 65 (lterm -> lfact .)


state 36

    (67) lfact -> FALSE .
    AND             reduce using rule 67 (lfact -> FALSE .)
    OR              reduce using rule 67 (lfact -> FALSE .)
    {               reduce using rule 67 (lfact -> FALSE .)
    FOR             reduce using rule 67 (lfact -> FALSE .)
    WHILE           reduce using rule 67 (lfact -> FALSE .)
    IF              reduce using rule 67 (lfact -> FALSE .)
    RETURN          reduce using rule 67 (lfact -> FALSE .)
    PRINT           reduce using rule 67 (lfact -> FALSE .)
    ID              reduce using rule 67 (lfact -> FALSE .)
    ;               reduce using rule 67 (lfact -> FALSE .)
    )               reduce using rule 67 (lfact -> FALSE .)
    ]               reduce using rule 67 (lfact -> FALSE .)
    ,               reduce using rule 67 (lfact -> FALSE .)


state 37

    (68) lfact -> TRUE .
    AND             reduce using rule 68 (lfact -> TRUE .)
    OR              reduce using rule 68 (lfact -> TRUE .)
    {               reduce using rule 68 (lfact -> TRUE .)
    FOR             reduce using rule 68 (lfact -> TRUE .)
    WHILE           reduce using rule 68 (lfact -> TRUE .)
    IF              reduce using rule 68 (lfact -> TRUE .)
    RETURN          reduce using rule 68 (lfact -> TRUE .)
    PRINT           reduce using rule 68 (lfact -> TRUE .)
    ID              reduce using rule 68 (lfact -> TRUE .)
    ;               reduce using rule 68 (lfact -> TRUE .)
    )               reduce using rule 68 (lfact -> TRUE .)
    ]               reduce using rule 68 (lfact -> TRUE .)
    ,               reduce using rule 68 (lfact -> TRUE .)


state 38

    (69) lfact -> NOT . lfact
    (67) lfact -> . FALSE
    (68) lfact -> . TRUE
    (69) lfact -> . NOT lfact
    (70) lfact -> . # ID [ aexpr ]
    (71) lfact -> . # ID
    (72) lfact -> . ( lexpr )
    (73) lfact -> . # call
    (74) lfact -> . cexpr
    (57) cexpr -> . aexpr LE aexpr
    (58) cexpr -> . aexpr LT aexpr
    (59) cexpr -> . aexpr GE aexpr
    (60) cexpr -> . aexpr GT aexpr
    (61) cexpr -> . aexpr NE aexpr
    (62) cexpr -> . aexpr EQ aexpr
    (45) aexpr -> . term
    (46) aexpr -> . aexpr MINUS term
    (47) aexpr -> . aexpr PLUS term
    (48) term -> . fact
    (49) term -> . term TIMES fact
    (50) term -> . term DIVIDE fact
    (51) fact -> . ID [ aexpr ]
    (52) fact -> . ID
    (53) fact -> . ( aexpr )
    (54) fact -> . NUMBER
    (55) fact -> . call
    (56) fact -> . MINUS fact
    (75) call -> . ID ( args )
    FALSE           shift and go to state 36
    TRUE            shift and go to state 37
    NOT             shift and go to state 38
    #               shift and go to state 39
    (               shift and go to state 42
    ID              shift and go to state 40
    NUMBER          shift and go to state 48
    MINUS           shift and go to state 46

    lfact                          shift and go to state 71
    aexpr                          shift and go to state 41
    call                           shift and go to state 43
    cexpr                          shift and go to state 44
    term                           shift and go to state 45
    fact                           shift and go to state 47

state 39

    (70) lfact -> # . ID [ aexpr ]
    (71) lfact -> # . ID
    (73) lfact -> # . call
    (75) call -> . ID ( args )
    ID              shift and go to state 72

    call                           shift and go to state 73

state 40

    (51) fact -> ID . [ aexpr ]
    (52) fact -> ID .
    (75) call -> ID . ( args )
    [               shift and go to state 74
    TIMES           reduce using rule 52 (fact -> ID .)
    DIVIDE          reduce using rule 52 (fact -> ID .)
    LE              reduce using rule 52 (fact -> ID .)
    LT              reduce using rule 52 (fact -> ID .)
    GE              reduce using rule 52 (fact -> ID .)
    GT              reduce using rule 52 (fact -> ID .)
    NE              reduce using rule 52 (fact -> ID .)
    EQ              reduce using rule 52 (fact -> ID .)
    MINUS           reduce using rule 52 (fact -> ID .)
    PLUS            reduce using rule 52 (fact -> ID .)
    ;               reduce using rule 52 (fact -> ID .)
    )               reduce using rule 52 (fact -> ID .)
    ]               reduce using rule 52 (fact -> ID .)
    ,               reduce using rule 52 (fact -> ID .)
    AND             reduce using rule 52 (fact -> ID .)
    OR              reduce using rule 52 (fact -> ID .)
    {               reduce using rule 52 (fact -> ID .)
    FOR             reduce using rule 52 (fact -> ID .)
    WHILE           reduce using rule 52 (fact -> ID .)
    IF              reduce using rule 52 (fact -> ID .)
    RETURN          reduce using rule 52 (fact -> ID .)
    PRINT           reduce using rule 52 (fact -> ID .)
    ID              reduce using rule 52 (fact -> ID .)
    (               shift and go to state 75


state 41

    (57) cexpr -> aexpr . LE aexpr
    (58) cexpr -> aexpr . LT aexpr
    (59) cexpr -> aexpr . GE aexpr
    (60) cexpr -> aexpr . GT aexpr
    (61) cexpr -> aexpr . NE aexpr
    (62) cexpr -> aexpr . EQ aexpr
    (46) aexpr -> aexpr . MINUS term
    (47) aexpr -> aexpr . PLUS term
    LE              shift and go to state 76
    LT              shift and go to state 77
    GE              shift and go to state 78
    GT              shift and go to state 79
    NE              shift and go to state 80
    EQ              shift and go to state 81
    MINUS           shift and go to state 82
    PLUS            shift and go to state 83


state 42

    (72) lfact -> ( . lexpr )
    (53) fact -> ( . aexpr )
    (63) lexpr -> . lterm
    (64) lexpr -> . lexpr OR lterm
    (45) aexpr -> . term
    (46) aexpr -> . aexpr MINUS term
    (47) aexpr -> . aexpr PLUS term
    (65) lterm -> . lfact
    (66) lterm -> . lterm AND lfact
    (48) term -> . fact
    (49) term -> . term TIMES fact
    (50) term -> . term DIVIDE fact
    (67) lfact -> . FALSE
    (68) lfact -> . TRUE
    (69) lfact -> . NOT lfact
    (70) lfact -> . # ID [ aexpr ]
    (71) lfact -> . # ID
    (72) lfact -> . ( lexpr )
    (73) lfact -> . # call
    (74) lfact -> . cexpr
    (51) fact -> . ID [ aexpr ]
    (52) fact -> . ID
    (53) fact -> . ( aexpr )
    (54) fact -> . NUMBER
    (55) fact -> . call
    (56) fact -> . MINUS fact
    (57) cexpr -> . aexpr LE aexpr
    (58) cexpr -> . aexpr LT aexpr
    (59) cexpr -> . aexpr GE aexpr
    (60) cexpr -> . aexpr GT aexpr
    (61) cexpr -> . aexpr NE aexpr
    (62) cexpr -> . aexpr EQ aexpr
    (75) call -> . ID ( args )
    FALSE           shift and go to state 36
    TRUE            shift and go to state 37
    NOT             shift and go to state 38
    #               shift and go to state 39
    (               shift and go to state 42
    ID              shift and go to state 40
    NUMBER          shift and go to state 48
    MINUS           shift and go to state 46

    lexpr                          shift and go to state 84
    aexpr                          shift and go to state 85
    lterm                          shift and go to state 34
    term                           shift and go to state 45
    lfact                          shift and go to state 35
    fact                           shift and go to state 47
    call                           shift and go to state 43
    cexpr                          shift and go to state 44

state 43

    (55) fact -> call .
    TIMES           reduce using rule 55 (fact -> call .)
    DIVIDE          reduce using rule 55 (fact -> call .)
    LE              reduce using rule 55 (fact -> call .)
    LT              reduce using rule 55 (fact -> call .)
    GE              reduce using rule 55 (fact -> call .)
    GT              reduce using rule 55 (fact -> call .)
    NE              reduce using rule 55 (fact -> call .)
    EQ              reduce using rule 55 (fact -> call .)
    MINUS           reduce using rule 55 (fact -> call .)
    PLUS            reduce using rule 55 (fact -> call .)
    ;               reduce using rule 55 (fact -> call .)
    )               reduce using rule 55 (fact -> call .)
    ]               reduce using rule 55 (fact -> call .)
    ,               reduce using rule 55 (fact -> call .)
    AND             reduce using rule 55 (fact -> call .)
    OR              reduce using rule 55 (fact -> call .)
    {               reduce using rule 55 (fact -> call .)
    FOR             reduce using rule 55 (fact -> call .)
    WHILE           reduce using rule 55 (fact -> call .)
    IF              reduce using rule 55 (fact -> call .)
    RETURN          reduce using rule 55 (fact -> call .)
    PRINT           reduce using rule 55 (fact -> call .)
    ID              reduce using rule 55 (fact -> call .)


state 44

    (74) lfact -> cexpr .
    AND             reduce using rule 74 (lfact -> cexpr .)
    OR              reduce using rule 74 (lfact -> cexpr .)
    {               reduce using rule 74 (lfact -> cexpr .)
    FOR             reduce using rule 74 (lfact -> cexpr .)
    WHILE           reduce using rule 74 (lfact -> cexpr .)
    IF              reduce using rule 74 (lfact -> cexpr .)
    RETURN          reduce using rule 74 (lfact -> cexpr .)
    PRINT           reduce using rule 74 (lfact -> cexpr .)
    ID              reduce using rule 74 (lfact -> cexpr .)
    ;               reduce using rule 74 (lfact -> cexpr .)
    )               reduce using rule 74 (lfact -> cexpr .)
    ]               reduce using rule 74 (lfact -> cexpr .)
    ,               reduce using rule 74 (lfact -> cexpr .)


state 45

    (45) aexpr -> term .
    (49) term -> term . TIMES fact
    (50) term -> term . DIVIDE fact
    LE              reduce using rule 45 (aexpr -> term .)
    LT              reduce using rule 45 (aexpr -> term .)
    GE              reduce using rule 45 (aexpr -> term .)
    GT              reduce using rule 45 (aexpr -> term .)
    NE              reduce using rule 45 (aexpr -> term .)
    EQ              reduce using rule 45 (aexpr -> term .)
    MINUS           reduce using rule 45 (aexpr -> term .)
    PLUS            reduce using rule 45 (aexpr -> term .)
    ;               reduce using rule 45 (aexpr -> term .)
    )               reduce using rule 45 (aexpr -> term .)
    ]               reduce using rule 45 (aexpr -> term .)
    ,               reduce using rule 45 (aexpr -> term .)
    AND             reduce using rule 45 (aexpr -> term .)
    OR              reduce using rule 45 (aexpr -> term .)
    {               reduce using rule 45 (aexpr -> term .)
    FOR             reduce using rule 45 (aexpr -> term .)
    WHILE           reduce using rule 45 (aexpr -> term .)
    IF              reduce using rule 45 (aexpr -> term .)
    RETURN          reduce using rule 45 (aexpr -> term .)
    PRINT           reduce using rule 45 (aexpr -> term .)
    ID              reduce using rule 45 (aexpr -> term .)
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87


state 46

    (56) fact -> MINUS . fact
    (51) fact -> . ID [ aexpr ]
    (52) fact -> . ID
    (53) fact -> . ( aexpr )
    (54) fact -> . NUMBER
    (55) fact -> . call
    (56) fact -> . MINUS fact
    (75) call -> . ID ( args )
    ID              shift and go to state 40
    (               shift and go to state 89
    NUMBER          shift and go to state 48
    MINUS           shift and go to state 46

    fact                           shift and go to state 88
    call                           shift and go to state 43

state 47

    (48) term -> fact .
    TIMES           reduce using rule 48 (term -> fact .)
    DIVIDE          reduce using rule 48 (term -> fact .)
    LE              reduce using rule 48 (term -> fact .)
    LT              reduce using rule 48 (term -> fact .)
    GE              reduce using rule 48 (term -> fact .)
    GT              reduce using rule 48 (term -> fact .)
    NE              reduce using rule 48 (term -> fact .)
    EQ              reduce using rule 48 (term -> fact .)
    MINUS           reduce using rule 48 (term -> fact .)
    PLUS            reduce using rule 48 (term -> fact .)
    ;               reduce using rule 48 (term -> fact .)
    )               reduce using rule 48 (term -> fact .)
    ]               reduce using rule 48 (term -> fact .)
    ,               reduce using rule 48 (term -> fact .)
    AND             reduce using rule 48 (term -> fact .)
    OR              reduce using rule 48 (term -> fact .)
    {               reduce using rule 48 (term -> fact .)
    FOR             reduce using rule 48 (term -> fact .)
    WHILE           reduce using rule 48 (term -> fact .)
    IF              reduce using rule 48 (term -> fact .)
    RETURN          reduce using rule 48 (term -> fact .)
    PRINT           reduce using rule 48 (term -> fact .)
    ID              reduce using rule 48 (term -> fact .)


state 48

    (54) fact -> NUMBER .
    TIMES           reduce using rule 54 (fact -> NUMBER .)
    DIVIDE          reduce using rule 54 (fact -> NUMBER .)
    LE              reduce using rule 54 (fact -> NUMBER .)
    LT              reduce using rule 54 (fact -> NUMBER .)
    GE              reduce using rule 54 (fact -> NUMBER .)
    GT              reduce using rule 54 (fact -> NUMBER .)
    NE              reduce using rule 54 (fact -> NUMBER .)
    EQ              reduce using rule 54 (fact -> NUMBER .)
    MINUS           reduce using rule 54 (fact -> NUMBER .)
    PLUS            reduce using rule 54 (fact -> NUMBER .)
    ;               reduce using rule 54 (fact -> NUMBER .)
    )               reduce using rule 54 (fact -> NUMBER .)
    ]               reduce using rule 54 (fact -> NUMBER .)
    ,               reduce using rule 54 (fact -> NUMBER .)
    AND             reduce using rule 54 (fact -> NUMBER .)
    OR              reduce using rule 54 (fact -> NUMBER .)
    {               reduce using rule 54 (fact -> NUMBER .)
    FOR             reduce using rule 54 (fact -> NUMBER .)
    WHILE           reduce using rule 54 (fact -> NUMBER .)
    IF              reduce using rule 54 (fact -> NUMBER .)
    RETURN          reduce using rule 54 (fact -> NUMBER .)
    PRINT           reduce using rule 54 (fact -> NUMBER .)
    ID              reduce using rule 54 (fact -> NUMBER .)


state 49

    (33) if_stmt -> IF lexpr . stmt ELSE stmt
    (34) if_stmt -> IF lexpr . stmt
    (64) lexpr -> lexpr . OR lterm
    (19) stmt -> . block
    (20) stmt -> . free_stmt
    (16) block -> . { V S }
    (21) free_stmt -> . compound_stmt
    (22) free_stmt -> . simple_stmt ;
    (30) compound_stmt -> . for_stmt
    (31) compound_stmt -> . while_stmt
    (32) compound_stmt -> . if_stmt
    (25) simple_stmt -> . return_stmt
    (26) simple_stmt -> . print_stmt
    (27) simple_stmt -> . asgn_stmt
    (36) for_stmt -> . FOR ( for_asgn ; for_lexpr ; for_asgn ) stmt
    (35) while_stmt -> . WHILE lexpr stmt
    (33) if_stmt -> . IF lexpr stmt ELSE stmt
    (34) if_stmt -> . IF lexpr stmt
    (29) return_stmt -> . RETURN expr
    (28) print_stmt -> . PRINT expr
    (23) asgn_stmt -> . ID [ aexpr ] ASSIGN expr
    (24) asgn_stmt -> . ID ASSIGN expr
    OR              shift and go to state 66
    {               shift and go to state 69
    FOR             shift and go to state 22
    WHILE           shift and go to state 23
    IF              shift and go to state 24
    RETURN          shift and go to state 25
    PRINT           shift and go to state 26
    ID              shift and go to state 27

    stmt                           shift and go to state 90
    block                          shift and go to state 67
    free_stmt                      shift and go to state 68
    compound_stmt                  shift and go to state 14
    simple_stmt                    shift and go to state 15
    for_stmt                       shift and go to state 16
    while_stmt                     shift and go to state 17
    if_stmt                        shift and go to state 18
    return_stmt                    shift and go to state 19
    print_stmt                     shift and go to state 20
    asgn_stmt                      shift and go to state 21

state 50

    (29) return_stmt -> RETURN expr .
    ;               reduce using rule 29 (return_stmt -> RETURN expr .)


state 51

    (41) expr -> aexpr .
    (46) aexpr -> aexpr . MINUS term
    (47) aexpr -> aexpr . PLUS term
    (57) cexpr -> aexpr . LE aexpr
    (58) cexpr -> aexpr . LT aexpr
    (59) cexpr -> aexpr . GE aexpr
    (60) cexpr -> aexpr . GT aexpr
    (61) cexpr -> aexpr . NE aexpr
    (62) cexpr -> aexpr . EQ aexpr
    ;               reduce using rule 41 (expr -> aexpr .)
    )               reduce using rule 41 (expr -> aexpr .)
    ]               reduce using rule 41 (expr -> aexpr .)
    ,               reduce using rule 41 (expr -> aexpr .)
    MINUS           shift and go to state 82
    PLUS            shift and go to state 83
    LE              shift and go to state 76
    LT              shift and go to state 77
    GE              shift and go to state 78
    GT              shift and go to state 79
    NE              shift and go to state 80
    EQ              shift and go to state 81


state 52

    (42) expr -> sexpr .
    ;               reduce using rule 42 (expr -> sexpr .)
    )               reduce using rule 42 (expr -> sexpr .)
    ]               reduce using rule 42 (expr -> sexpr .)
    ,               reduce using rule 42 (expr -> sexpr .)


state 53

    (43) expr -> lexpr .
    (64) lexpr -> lexpr . OR lterm
    ;               reduce using rule 43 (expr -> lexpr .)
    )               reduce using rule 43 (expr -> lexpr .)
    ]               reduce using rule 43 (expr -> lexpr .)
    ,               reduce using rule 43 (expr -> lexpr .)
    OR              shift and go to state 66


state 54

    (44) sexpr -> STRING .
    ;               reduce using rule 44 (sexpr -> STRING .)
    )               reduce using rule 44 (sexpr -> STRING .)
    ]               reduce using rule 44 (sexpr -> STRING .)
    ,               reduce using rule 44 (sexpr -> STRING .)


state 55

    (53) fact -> ( . aexpr )
    (72) lfact -> ( . lexpr )
    (45) aexpr -> . term
    (46) aexpr -> . aexpr MINUS term
    (47) aexpr -> . aexpr PLUS term
    (63) lexpr -> . lterm
    (64) lexpr -> . lexpr OR lterm
    (48) term -> . fact
    (49) term -> . term TIMES fact
    (50) term -> . term DIVIDE fact
    (65) lterm -> . lfact
    (66) lterm -> . lterm AND lfact
    (51) fact -> . ID [ aexpr ]
    (52) fact -> . ID
    (53) fact -> . ( aexpr )
    (54) fact -> . NUMBER
    (55) fact -> . call
    (56) fact -> . MINUS fact
    (67) lfact -> . FALSE
    (68) lfact -> . TRUE
    (69) lfact -> . NOT lfact
    (70) lfact -> . # ID [ aexpr ]
    (71) lfact -> . # ID
    (72) lfact -> . ( lexpr )
    (73) lfact -> . # call
    (74) lfact -> . cexpr
    (75) call -> . ID ( args )
    (57) cexpr -> . aexpr LE aexpr
    (58) cexpr -> . aexpr LT aexpr
    (59) cexpr -> . aexpr GE aexpr
    (60) cexpr -> . aexpr GT aexpr
    (61) cexpr -> . aexpr NE aexpr
    (62) cexpr -> . aexpr EQ aexpr
    ID              shift and go to state 40
    (               shift and go to state 55
    NUMBER          shift and go to state 48
    MINUS           shift and go to state 46
    FALSE           shift and go to state 36
    TRUE            shift and go to state 37
    NOT             shift and go to state 38
    #               shift and go to state 39

    aexpr                          shift and go to state 85
    lexpr                          shift and go to state 84
    term                           shift and go to state 45
    lterm                          shift and go to state 34
    fact                           shift and go to state 47
    lfact                          shift and go to state 35
    call                           shift and go to state 43
    cexpr                          shift and go to state 44

state 56

    (28) print_stmt -> PRINT expr .
    ;               reduce using rule 28 (print_stmt -> PRINT expr .)


state 57

    (23) asgn_stmt -> ID [ . aexpr ] ASSIGN expr
    (45) aexpr -> . term
    (46) aexpr -> . aexpr MINUS term
    (47) aexpr -> . aexpr PLUS term
    (48) term -> . fact
    (49) term -> . term TIMES fact
    (50) term -> . term DIVIDE fact
    (51) fact -> . ID [ aexpr ]
    (52) fact -> . ID
    (53) fact -> . ( aexpr )
    (54) fact -> . NUMBER
    (55) fact -> . call
    (56) fact -> . MINUS fact
    (75) call -> . ID ( args )
    ID              shift and go to state 40
    (               shift and go to state 89
    NUMBER          shift and go to state 48
    MINUS           shift and go to state 46

    aexpr                          shift and go to state 91
    term                           shift and go to state 45
    fact                           shift and go to state 47
    call                           shift and go to state 43

state 58

    (24) asgn_stmt -> ID ASSIGN . expr
    (41) expr -> . aexpr
    (42) expr -> . sexpr
    (43) expr -> . lexpr
    (45) aexpr -> . term
    (46) aexpr -> . aexpr MINUS term
    (47) aexpr -> . aexpr PLUS term
    (44) sexpr -> . STRING
    (63) lexpr -> . lterm
    (64) lexpr -> . lexpr OR lterm
    (48) term -> . fact
    (49) term -> . term TIMES fact
    (50) term -> . term DIVIDE fact
    (65) lterm -> . lfact
    (66) lterm -> . lterm AND lfact
    (51) fact -> . ID [ aexpr ]
    (52) fact -> . ID
    (53) fact -> . ( aexpr )
    (54) fact -> . NUMBER
    (55) fact -> . call
    (56) fact -> . MINUS fact
    (67) lfact -> . FALSE
    (68) lfact -> . TRUE
    (69) lfact -> . NOT lfact
    (70) lfact -> . # ID [ aexpr ]
    (71) lfact -> . # ID
    (72) lfact -> . ( lexpr )
    (73) lfact -> . # call
    (74) lfact -> . cexpr
    (75) call -> . ID ( args )
    (57) cexpr -> . aexpr LE aexpr
    (58) cexpr -> . aexpr LT aexpr
    (59) cexpr -> . aexpr GE aexpr
    (60) cexpr -> . aexpr GT aexpr
    (61) cexpr -> . aexpr NE aexpr
    (62) cexpr -> . aexpr EQ aexpr
    STRING          shift and go to state 54
    ID              shift and go to state 40
    (               shift and go to state 55
    NUMBER          shift and go to state 48
    MINUS           shift and go to state 46
    FALSE           shift and go to state 36
    TRUE            shift and go to state 37
    NOT             shift and go to state 38
    #               shift and go to state 39

    expr                           shift and go to state 92
    aexpr                          shift and go to state 51
    sexpr                          shift and go to state 52
    lexpr                          shift and go to state 53
    term                           shift and go to state 45
    lterm                          shift and go to state 34
    fact                           shift and go to state 47
    lfact                          shift and go to state 35
    call                           shift and go to state 43
    cexpr                          shift and go to state 44

state 59

    (11) funDecl -> FUN ID ( . parameters ) block
    (12) parameters -> . P
    (13) parameters -> . empty
    (14) P -> . P , ID
    (15) P -> . ID
    (80) empty -> .
    ID              shift and go to state 93
    )               reduce using rule 80 (empty -> .)

    parameters                     shift and go to state 94
    P                              shift and go to state 95
    empty                          shift and go to state 96

state 60

    (4) varDecl -> VAR ID ASSIGN [ . Vexprs ] ;
    (7) Vexprs -> . expr
    (8) Vexprs -> . Vexprs , expr
    (41) expr -> . aexpr
    (42) expr -> . sexpr
    (43) expr -> . lexpr
    (45) aexpr -> . term
    (46) aexpr -> . aexpr MINUS term
    (47) aexpr -> . aexpr PLUS term
    (44) sexpr -> . STRING
    (63) lexpr -> . lterm
    (64) lexpr -> . lexpr OR lterm
    (48) term -> . fact
    (49) term -> . term TIMES fact
    (50) term -> . term DIVIDE fact
    (65) lterm -> . lfact
    (66) lterm -> . lterm AND lfact
    (51) fact -> . ID [ aexpr ]
    (52) fact -> . ID
    (53) fact -> . ( aexpr )
    (54) fact -> . NUMBER
    (55) fact -> . call
    (56) fact -> . MINUS fact
    (67) lfact -> . FALSE
    (68) lfact -> . TRUE
    (69) lfact -> . NOT lfact
    (70) lfact -> . # ID [ aexpr ]
    (71) lfact -> . # ID
    (72) lfact -> . ( lexpr )
    (73) lfact -> . # call
    (74) lfact -> . cexpr
    (75) call -> . ID ( args )
    (57) cexpr -> . aexpr LE aexpr
    (58) cexpr -> . aexpr LT aexpr
    (59) cexpr -> . aexpr GE aexpr
    (60) cexpr -> . aexpr GT aexpr
    (61) cexpr -> . aexpr NE aexpr
    (62) cexpr -> . aexpr EQ aexpr
    STRING          shift and go to state 54
    ID              shift and go to state 40
    (               shift and go to state 55
    NUMBER          shift and go to state 48
    MINUS           shift and go to state 46
    FALSE           shift and go to state 36
    TRUE            shift and go to state 37
    NOT             shift and go to state 38
    #               shift and go to state 39

    Vexprs                         shift and go to state 97
    expr                           shift and go to state 98
    aexpr                          shift and go to state 51
    sexpr                          shift and go to state 52
    lexpr                          shift and go to state 53
    term                           shift and go to state 45
    lterm                          shift and go to state 34
    fact                           shift and go to state 47
    lfact                          shift and go to state 35
    call                           shift and go to state 43
    cexpr                          shift and go to state 44

state 61

    (5) varDecl -> VAR ID ASSIGN expr . ;
    ;               shift and go to state 99


state 62

    (36) for_stmt -> FOR ( for_asgn . ; for_lexpr ; for_asgn ) stmt
    ;               shift and go to state 100


state 63

    (37) for_asgn -> empty .
    ;               reduce using rule 37 (for_asgn -> empty .)
    )               reduce using rule 37 (for_asgn -> empty .)


state 64

    (38) for_asgn -> asgn_stmt .
    ;               reduce using rule 38 (for_asgn -> asgn_stmt .)
    )               reduce using rule 38 (for_asgn -> asgn_stmt .)


state 65

    (35) while_stmt -> WHILE lexpr stmt .
    FOR             reduce using rule 35 (while_stmt -> WHILE lexpr stmt .)
    WHILE           reduce using rule 35 (while_stmt -> WHILE lexpr stmt .)
    IF              reduce using rule 35 (while_stmt -> WHILE lexpr stmt .)
    RETURN          reduce using rule 35 (while_stmt -> WHILE lexpr stmt .)
    PRINT           reduce using rule 35 (while_stmt -> WHILE lexpr stmt .)
    ID              reduce using rule 35 (while_stmt -> WHILE lexpr stmt .)
    $end            reduce using rule 35 (while_stmt -> WHILE lexpr stmt .)
    ELSE            reduce using rule 35 (while_stmt -> WHILE lexpr stmt .)
    }               reduce using rule 35 (while_stmt -> WHILE lexpr stmt .)


state 66

    (64) lexpr -> lexpr OR . lterm
    (65) lterm -> . lfact
    (66) lterm -> . lterm AND lfact
    (67) lfact -> . FALSE
    (68) lfact -> . TRUE
    (69) lfact -> . NOT lfact
    (70) lfact -> . # ID [ aexpr ]
    (71) lfact -> . # ID
    (72) lfact -> . ( lexpr )
    (73) lfact -> . # call
    (74) lfact -> . cexpr
    (57) cexpr -> . aexpr LE aexpr
    (58) cexpr -> . aexpr LT aexpr
    (59) cexpr -> . aexpr GE aexpr
    (60) cexpr -> . aexpr GT aexpr
    (61) cexpr -> . aexpr NE aexpr
    (62) cexpr -> . aexpr EQ aexpr
    (45) aexpr -> . term
    (46) aexpr -> . aexpr MINUS term
    (47) aexpr -> . aexpr PLUS term
    (48) term -> . fact
    (49) term -> . term TIMES fact
    (50) term -> . term DIVIDE fact
    (51) fact -> . ID [ aexpr ]
    (52) fact -> . ID
    (53) fact -> . ( aexpr )
    (54) fact -> . NUMBER
    (55) fact -> . call
    (56) fact -> . MINUS fact
    (75) call -> . ID ( args )
    FALSE           shift and go to state 36
    TRUE            shift and go to state 37
    NOT             shift and go to state 38
    #               shift and go to state 39
    (               shift and go to state 42
    ID              shift and go to state 40
    NUMBER          shift and go to state 48
    MINUS           shift and go to state 46

    lterm                          shift and go to state 101
    lfact                          shift and go to state 35
    aexpr                          shift and go to state 41
    call                           shift and go to state 43
    cexpr                          shift and go to state 44
    term                           shift and go to state 45
    fact                           shift and go to state 47

state 67

    (19) stmt -> block .
    FOR             reduce using rule 19 (stmt -> block .)
    WHILE           reduce using rule 19 (stmt -> block .)
    IF              reduce using rule 19 (stmt -> block .)
    RETURN          reduce using rule 19 (stmt -> block .)
    PRINT           reduce using rule 19 (stmt -> block .)
    ID              reduce using rule 19 (stmt -> block .)
    $end            reduce using rule 19 (stmt -> block .)
    ELSE            reduce using rule 19 (stmt -> block .)
    }               reduce using rule 19 (stmt -> block .)


state 68

    (20) stmt -> free_stmt .
    FOR             reduce using rule 20 (stmt -> free_stmt .)
    WHILE           reduce using rule 20 (stmt -> free_stmt .)
    IF              reduce using rule 20 (stmt -> free_stmt .)
    RETURN          reduce using rule 20 (stmt -> free_stmt .)
    PRINT           reduce using rule 20 (stmt -> free_stmt .)
    ID              reduce using rule 20 (stmt -> free_stmt .)
    $end            reduce using rule 20 (stmt -> free_stmt .)
    ELSE            reduce using rule 20 (stmt -> free_stmt .)
    }               reduce using rule 20 (stmt -> free_stmt .)


state 69

    (16) block -> { . V S }
    (2) V -> . empty
    (3) V -> . V varDecl
    (80) empty -> .
    VAR             reduce using rule 80 (empty -> .)
    }               reduce using rule 80 (empty -> .)
    FOR             reduce using rule 80 (empty -> .)
    WHILE           reduce using rule 80 (empty -> .)
    IF              reduce using rule 80 (empty -> .)
    RETURN          reduce using rule 80 (empty -> .)
    PRINT           reduce using rule 80 (empty -> .)
    ID              reduce using rule 80 (empty -> .)

    V                              shift and go to state 102
    empty                          shift and go to state 3

state 70

    (66) lterm -> lterm AND . lfact
    (67) lfact -> . FALSE
    (68) lfact -> . TRUE
    (69) lfact -> . NOT lfact
    (70) lfact -> . # ID [ aexpr ]
    (71) lfact -> . # ID
    (72) lfact -> . ( lexpr )
    (73) lfact -> . # call
    (74) lfact -> . cexpr
    (57) cexpr -> . aexpr LE aexpr
    (58) cexpr -> . aexpr LT aexpr
    (59) cexpr -> . aexpr GE aexpr
    (60) cexpr -> . aexpr GT aexpr
    (61) cexpr -> . aexpr NE aexpr
    (62) cexpr -> . aexpr EQ aexpr
    (45) aexpr -> . term
    (46) aexpr -> . aexpr MINUS term
    (47) aexpr -> . aexpr PLUS term
    (48) term -> . fact
    (49) term -> . term TIMES fact
    (50) term -> . term DIVIDE fact
    (51) fact -> . ID [ aexpr ]
    (52) fact -> . ID
    (53) fact -> . ( aexpr )
    (54) fact -> . NUMBER
    (55) fact -> . call
    (56) fact -> . MINUS fact
    (75) call -> . ID ( args )
    FALSE           shift and go to state 36
    TRUE            shift and go to state 37
    NOT             shift and go to state 38
    #               shift and go to state 39
    (               shift and go to state 42
    ID              shift and go to state 40
    NUMBER          shift and go to state 48
    MINUS           shift and go to state 46

    lfact                          shift and go to state 103
    aexpr                          shift and go to state 41
    call                           shift and go to state 43
    cexpr                          shift and go to state 44
    term                           shift and go to state 45
    fact                           shift and go to state 47

state 71

    (69) lfact -> NOT lfact .
    AND             reduce using rule 69 (lfact -> NOT lfact .)
    OR              reduce using rule 69 (lfact -> NOT lfact .)
    {               reduce using rule 69 (lfact -> NOT lfact .)
    FOR             reduce using rule 69 (lfact -> NOT lfact .)
    WHILE           reduce using rule 69 (lfact -> NOT lfact .)
    IF              reduce using rule 69 (lfact -> NOT lfact .)
    RETURN          reduce using rule 69 (lfact -> NOT lfact .)
    PRINT           reduce using rule 69 (lfact -> NOT lfact .)
    ID              reduce using rule 69 (lfact -> NOT lfact .)
    ;               reduce using rule 69 (lfact -> NOT lfact .)
    )               reduce using rule 69 (lfact -> NOT lfact .)
    ]               reduce using rule 69 (lfact -> NOT lfact .)
    ,               reduce using rule 69 (lfact -> NOT lfact .)


state 72

    (70) lfact -> # ID . [ aexpr ]
    (71) lfact -> # ID .
    (75) call -> ID . ( args )
    [               shift and go to state 104
    AND             reduce using rule 71 (lfact -> # ID .)
    OR              reduce using rule 71 (lfact -> # ID .)
    {               reduce using rule 71 (lfact -> # ID .)
    FOR             reduce using rule 71 (lfact -> # ID .)
    WHILE           reduce using rule 71 (lfact -> # ID .)
    IF              reduce using rule 71 (lfact -> # ID .)
    RETURN          reduce using rule 71 (lfact -> # ID .)
    PRINT           reduce using rule 71 (lfact -> # ID .)
    ID              reduce using rule 71 (lfact -> # ID .)
    ;               reduce using rule 71 (lfact -> # ID .)
    )               reduce using rule 71 (lfact -> # ID .)
    ]               reduce using rule 71 (lfact -> # ID .)
    ,               reduce using rule 71 (lfact -> # ID .)
    (               shift and go to state 75


state 73

    (73) lfact -> # call .
    AND             reduce using rule 73 (lfact -> # call .)
    OR              reduce using rule 73 (lfact -> # call .)
    {               reduce using rule 73 (lfact -> # call .)
    FOR             reduce using rule 73 (lfact -> # call .)
    WHILE           reduce using rule 73 (lfact -> # call .)
    IF              reduce using rule 73 (lfact -> # call .)
    RETURN          reduce using rule 73 (lfact -> # call .)
    PRINT           reduce using rule 73 (lfact -> # call .)
    ID              reduce using rule 73 (lfact -> # call .)
    ;               reduce using rule 73 (lfact -> # call .)
    )               reduce using rule 73 (lfact -> # call .)
    ]               reduce using rule 73 (lfact -> # call .)
    ,               reduce using rule 73 (lfact -> # call .)


state 74

    (51) fact -> ID [ . aexpr ]
    (45) aexpr -> . term
    (46) aexpr -> . aexpr MINUS term
    (47) aexpr -> . aexpr PLUS term
    (48) term -> . fact
    (49) term -> . term TIMES fact
    (50) term -> . term DIVIDE fact
    (51) fact -> . ID [ aexpr ]
    (52) fact -> . ID
    (53) fact -> . ( aexpr )
    (54) fact -> . NUMBER
    (55) fact -> . call
    (56) fact -> . MINUS fact
    (75) call -> . ID ( args )
    ID              shift and go to state 40
    (               shift and go to state 89
    NUMBER          shift and go to state 48
    MINUS           shift and go to state 46

    aexpr                          shift and go to state 105
    term                           shift and go to state 45
    fact                           shift and go to state 47
    call                           shift and go to state 43

state 75

    (75) call -> ID ( . args )
    (76) args -> . A
    (77) args -> . empty
    (78) A -> . A , expr
    (79) A -> . expr
    (80) empty -> .
    (41) expr -> . aexpr
    (42) expr -> . sexpr
    (43) expr -> . lexpr
    (45) aexpr -> . term
    (46) aexpr -> . aexpr MINUS term
    (47) aexpr -> . aexpr PLUS term
    (44) sexpr -> . STRING
    (63) lexpr -> . lterm
    (64) lexpr -> . lexpr OR lterm
    (48) term -> . fact
    (49) term -> . term TIMES fact
    (50) term -> . term DIVIDE fact
    (65) lterm -> . lfact
    (66) lterm -> . lterm AND lfact
    (51) fact -> . ID [ aexpr ]
    (52) fact -> . ID
    (53) fact -> . ( aexpr )
    (54) fact -> . NUMBER
    (55) fact -> . call
    (56) fact -> . MINUS fact
    (67) lfact -> . FALSE
    (68) lfact -> . TRUE
    (69) lfact -> . NOT lfact
    (70) lfact -> . # ID [ aexpr ]
    (71) lfact -> . # ID
    (72) lfact -> . ( lexpr )
    (73) lfact -> . # call
    (74) lfact -> . cexpr
    (75) call -> . ID ( args )
    (57) cexpr -> . aexpr LE aexpr
    (58) cexpr -> . aexpr LT aexpr
    (59) cexpr -> . aexpr GE aexpr
    (60) cexpr -> . aexpr GT aexpr
    (61) cexpr -> . aexpr NE aexpr
    (62) cexpr -> . aexpr EQ aexpr
    )               reduce using rule 80 (empty -> .)
    STRING          shift and go to state 54
    ID              shift and go to state 40
    (               shift and go to state 55
    NUMBER          shift and go to state 48
    MINUS           shift and go to state 46
    FALSE           shift and go to state 36
    TRUE            shift and go to state 37
    NOT             shift and go to state 38
    #               shift and go to state 39

    args                           shift and go to state 106
    A                              shift and go to state 107
    empty                          shift and go to state 108
    expr                           shift and go to state 109
    aexpr                          shift and go to state 51
    sexpr                          shift and go to state 52
    lexpr                          shift and go to state 53
    term                           shift and go to state 45
    lterm                          shift and go to state 34
    fact                           shift and go to state 47
    lfact                          shift and go to state 35
    call                           shift and go to state 43
    cexpr                          shift and go to state 44

state 76

    (57) cexpr -> aexpr LE . aexpr
    (45) aexpr -> . term
    (46) aexpr -> . aexpr MINUS term
    (47) aexpr -> . aexpr PLUS term
    (48) term -> . fact
    (49) term -> . term TIMES fact
    (50) term -> . term DIVIDE fact
    (51) fact -> . ID [ aexpr ]
    (52) fact -> . ID
    (53) fact -> . ( aexpr )
    (54) fact -> . NUMBER
    (55) fact -> . call
    (56) fact -> . MINUS fact
    (75) call -> . ID ( args )
    ID              shift and go to state 40
    (               shift and go to state 89
    NUMBER          shift and go to state 48
    MINUS           shift and go to state 46

    aexpr                          shift and go to state 110
    term                           shift and go to state 45
    fact                           shift and go to state 47
    call                           shift and go to state 43

state 77

    (58) cexpr -> aexpr LT . aexpr
    (45) aexpr -> . term
    (46) aexpr -> . aexpr MINUS term
    (47) aexpr -> . aexpr PLUS term
    (48) term -> . fact
    (49) term -> . term TIMES fact
    (50) term -> . term DIVIDE fact
    (51) fact -> . ID [ aexpr ]
    (52) fact -> . ID
    (53) fact -> . ( aexpr )
    (54) fact -> . NUMBER
    (55) fact -> . call
    (56) fact -> . MINUS fact
    (75) call -> . ID ( args )
    ID              shift and go to state 40
    (               shift and go to state 89
    NUMBER          shift and go to state 48
    MINUS           shift and go to state 46

    aexpr                          shift and go to state 111
    term                           shift and go to state 45
    fact                           shift and go to state 47
    call                           shift and go to state 43

state 78

    (59) cexpr -> aexpr GE . aexpr
    (45) aexpr -> . term
    (46) aexpr -> . aexpr MINUS term
    (47) aexpr -> . aexpr PLUS term
    (48) term -> . fact
    (49) term -> . term TIMES fact
    (50) term -> . term DIVIDE fact
    (51) fact -> . ID [ aexpr ]
    (52) fact -> . ID
    (53) fact -> . ( aexpr )
    (54) fact -> . NUMBER
    (55) fact -> . call
    (56) fact -> . MINUS fact
    (75) call -> . ID ( args )
    ID              shift and go to state 40
    (               shift and go to state 89
    NUMBER          shift and go to state 48
    MINUS           shift and go to state 46

    aexpr                          shift and go to state 112
    term                           shift and go to state 45
    fact                           shift and go to state 47
    call                           shift and go to state 43

state 79

    (60) cexpr -> aexpr GT . aexpr
    (45) aexpr -> . term
    (46) aexpr -> . aexpr MINUS term
    (47) aexpr -> . aexpr PLUS term
    (48) term -> . fact
    (49) term -> . term TIMES fact
    (50) term -> . term DIVIDE fact
    (51) fact -> . ID [ aexpr ]
    (52) fact -> . ID
    (53) fact -> . ( aexpr )
    (54) fact -> . NUMBER
    (55) fact -> . call
    (56) fact -> . MINUS fact
    (75) call -> . ID ( args )
    ID              shift and go to state 40
    (               shift and go to state 89
    NUMBER          shift and go to state 48
    MINUS           shift and go to state 46

    aexpr                          shift and go to state 113
    term                           shift and go to state 45
    fact                           shift and go to state 47
    call                           shift and go to state 43

state 80

    (61) cexpr -> aexpr NE . aexpr
    (45) aexpr -> . term
    (46) aexpr -> . aexpr MINUS term
    (47) aexpr -> . aexpr PLUS term
    (48) term -> . fact
    (49) term -> . term TIMES fact
    (50) term -> . term DIVIDE fact
    (51) fact -> . ID [ aexpr ]
    (52) fact -> . ID
    (53) fact -> . ( aexpr )
    (54) fact -> . NUMBER
    (55) fact -> . call
    (56) fact -> . MINUS fact
    (75) call -> . ID ( args )
    ID              shift and go to state 40
    (               shift and go to state 89
    NUMBER          shift and go to state 48
    MINUS           shift and go to state 46

    aexpr                          shift and go to state 114
    term                           shift and go to state 45
    fact                           shift and go to state 47
    call                           shift and go to state 43

state 81

    (62) cexpr -> aexpr EQ . aexpr
    (45) aexpr -> . term
    (46) aexpr -> . aexpr MINUS term
    (47) aexpr -> . aexpr PLUS term
    (48) term -> . fact
    (49) term -> . term TIMES fact
    (50) term -> . term DIVIDE fact
    (51) fact -> . ID [ aexpr ]
    (52) fact -> . ID
    (53) fact -> . ( aexpr )
    (54) fact -> . NUMBER
    (55) fact -> . call
    (56) fact -> . MINUS fact
    (75) call -> . ID ( args )
    ID              shift and go to state 40
    (               shift and go to state 89
    NUMBER          shift and go to state 48
    MINUS           shift and go to state 46

    aexpr                          shift and go to state 115
    term                           shift and go to state 45
    fact                           shift and go to state 47
    call                           shift and go to state 43

state 82

    (46) aexpr -> aexpr MINUS . term
    (48) term -> . fact
    (49) term -> . term TIMES fact
    (50) term -> . term DIVIDE fact
    (51) fact -> . ID [ aexpr ]
    (52) fact -> . ID
    (53) fact -> . ( aexpr )
    (54) fact -> . NUMBER
    (55) fact -> . call
    (56) fact -> . MINUS fact
    (75) call -> . ID ( args )
    ID              shift and go to state 40
    (               shift and go to state 89
    NUMBER          shift and go to state 48
    MINUS           shift and go to state 46

    term                           shift and go to state 116
    fact                           shift and go to state 47
    call                           shift and go to state 43

state 83

    (47) aexpr -> aexpr PLUS . term
    (48) term -> . fact
    (49) term -> . term TIMES fact
    (50) term -> . term DIVIDE fact
    (51) fact -> . ID [ aexpr ]
    (52) fact -> . ID
    (53) fact -> . ( aexpr )
    (54) fact -> . NUMBER
    (55) fact -> . call
    (56) fact -> . MINUS fact
    (75) call -> . ID ( args )
    ID              shift and go to state 40
    (               shift and go to state 89
    NUMBER          shift and go to state 48
    MINUS           shift and go to state 46

    term                           shift and go to state 117
    fact                           shift and go to state 47
    call                           shift and go to state 43

state 84

    (72) lfact -> ( lexpr . )
    (64) lexpr -> lexpr . OR lterm
    )               shift and go to state 118
    OR              shift and go to state 66


state 85

    (53) fact -> ( aexpr . )
    (46) aexpr -> aexpr . MINUS term
    (47) aexpr -> aexpr . PLUS term
    (57) cexpr -> aexpr . LE aexpr
    (58) cexpr -> aexpr . LT aexpr
    (59) cexpr -> aexpr . GE aexpr
    (60) cexpr -> aexpr . GT aexpr
    (61) cexpr -> aexpr . NE aexpr
    (62) cexpr -> aexpr . EQ aexpr
    )               shift and go to state 119
    MINUS           shift and go to state 82
    PLUS            shift and go to state 83
    LE              shift and go to state 76
    LT              shift and go to state 77
    GE              shift and go to state 78
    GT              shift and go to state 79
    NE              shift and go to state 80
    EQ              shift and go to state 81


state 86

    (49) term -> term TIMES . fact
    (51) fact -> . ID [ aexpr ]
    (52) fact -> . ID
    (53) fact -> . ( aexpr )
    (54) fact -> . NUMBER
    (55) fact -> . call
    (56) fact -> . MINUS fact
    (75) call -> . ID ( args )
    ID              shift and go to state 40
    (               shift and go to state 89
    NUMBER          shift and go to state 48
    MINUS           shift and go to state 46

    fact                           shift and go to state 120
    call                           shift and go to state 43

state 87

    (50) term -> term DIVIDE . fact
    (51) fact -> . ID [ aexpr ]
    (52) fact -> . ID
    (53) fact -> . ( aexpr )
    (54) fact -> . NUMBER
    (55) fact -> . call
    (56) fact -> . MINUS fact
    (75) call -> . ID ( args )
    ID              shift and go to state 40
    (               shift and go to state 89
    NUMBER          shift and go to state 48
    MINUS           shift and go to state 46

    fact                           shift and go to state 121
    call                           shift and go to state 43

state 88

    (56) fact -> MINUS fact .
    TIMES           reduce using rule 56 (fact -> MINUS fact .)
    DIVIDE          reduce using rule 56 (fact -> MINUS fact .)
    LE              reduce using rule 56 (fact -> MINUS fact .)
    LT              reduce using rule 56 (fact -> MINUS fact .)
    GE              reduce using rule 56 (fact -> MINUS fact .)
    GT              reduce using rule 56 (fact -> MINUS fact .)
    NE              reduce using rule 56 (fact -> MINUS fact .)
    EQ              reduce using rule 56 (fact -> MINUS fact .)
    MINUS           reduce using rule 56 (fact -> MINUS fact .)
    PLUS            reduce using rule 56 (fact -> MINUS fact .)
    ;               reduce using rule 56 (fact -> MINUS fact .)
    )               reduce using rule 56 (fact -> MINUS fact .)
    ]               reduce using rule 56 (fact -> MINUS fact .)
    ,               reduce using rule 56 (fact -> MINUS fact .)
    AND             reduce using rule 56 (fact -> MINUS fact .)
    OR              reduce using rule 56 (fact -> MINUS fact .)
    {               reduce using rule 56 (fact -> MINUS fact .)
    FOR             reduce using rule 56 (fact -> MINUS fact .)
    WHILE           reduce using rule 56 (fact -> MINUS fact .)
    IF              reduce using rule 56 (fact -> MINUS fact .)
    RETURN          reduce using rule 56 (fact -> MINUS fact .)
    PRINT           reduce using rule 56 (fact -> MINUS fact .)
    ID              reduce using rule 56 (fact -> MINUS fact .)


state 89

    (53) fact -> ( . aexpr )
    (45) aexpr -> . term
    (46) aexpr -> . aexpr MINUS term
    (47) aexpr -> . aexpr PLUS term
    (48) term -> . fact
    (49) term -> . term TIMES fact
    (50) term -> . term DIVIDE fact
    (51) fact -> . ID [ aexpr ]
    (52) fact -> . ID
    (53) fact -> . ( aexpr )
    (54) fact -> . NUMBER
    (55) fact -> . call
    (56) fact -> . MINUS fact
    (75) call -> . ID ( args )
    ID              shift and go to state 40
    (               shift and go to state 89
    NUMBER          shift and go to state 48
    MINUS           shift and go to state 46

    aexpr                          shift and go to state 122
    term                           shift and go to state 45
    fact                           shift and go to state 47
    call                           shift and go to state 43

state 90

    (33) if_stmt -> IF lexpr stmt . ELSE stmt
    (34) if_stmt -> IF lexpr stmt .
  ! shift/reduce conflict for ELSE resolved as shift
    ELSE            shift and go to state 123
    FOR             reduce using rule 34 (if_stmt -> IF lexpr stmt .)
    WHILE           reduce using rule 34 (if_stmt -> IF lexpr stmt .)
    IF              reduce using rule 34 (if_stmt -> IF lexpr stmt .)
    RETURN          reduce using rule 34 (if_stmt -> IF lexpr stmt .)
    PRINT           reduce using rule 34 (if_stmt -> IF lexpr stmt .)
    ID              reduce using rule 34 (if_stmt -> IF lexpr stmt .)
    $end            reduce using rule 34 (if_stmt -> IF lexpr stmt .)
    }               reduce using rule 34 (if_stmt -> IF lexpr stmt .)


state 91

    (23) asgn_stmt -> ID [ aexpr . ] ASSIGN expr
    (46) aexpr -> aexpr . MINUS term
    (47) aexpr -> aexpr . PLUS term
    ]               shift and go to state 124
    MINUS           shift and go to state 82
    PLUS            shift and go to state 83


state 92

    (24) asgn_stmt -> ID ASSIGN expr .
    ;               reduce using rule 24 (asgn_stmt -> ID ASSIGN expr .)
    )               reduce using rule 24 (asgn_stmt -> ID ASSIGN expr .)


state 93

    (15) P -> ID .
    ,               reduce using rule 15 (P -> ID .)
    )               reduce using rule 15 (P -> ID .)


state 94

    (11) funDecl -> FUN ID ( parameters . ) block
    )               shift and go to state 125


state 95

    (12) parameters -> P .
    (14) P -> P . , ID
    )               reduce using rule 12 (parameters -> P .)
    ,               shift and go to state 126


state 96

    (13) parameters -> empty .
    )               reduce using rule 13 (parameters -> empty .)


state 97

    (4) varDecl -> VAR ID ASSIGN [ Vexprs . ] ;
    (8) Vexprs -> Vexprs . , expr
    ]               shift and go to state 127
    ,               shift and go to state 128


state 98

    (7) Vexprs -> expr .
    ]               reduce using rule 7 (Vexprs -> expr .)
    ,               reduce using rule 7 (Vexprs -> expr .)


state 99

    (5) varDecl -> VAR ID ASSIGN expr ; .
    VAR             reduce using rule 5 (varDecl -> VAR ID ASSIGN expr ; .)
    FUN             reduce using rule 5 (varDecl -> VAR ID ASSIGN expr ; .)
    FOR             reduce using rule 5 (varDecl -> VAR ID ASSIGN expr ; .)
    WHILE           reduce using rule 5 (varDecl -> VAR ID ASSIGN expr ; .)
    IF              reduce using rule 5 (varDecl -> VAR ID ASSIGN expr ; .)
    RETURN          reduce using rule 5 (varDecl -> VAR ID ASSIGN expr ; .)
    PRINT           reduce using rule 5 (varDecl -> VAR ID ASSIGN expr ; .)
    ID              reduce using rule 5 (varDecl -> VAR ID ASSIGN expr ; .)
    $end            reduce using rule 5 (varDecl -> VAR ID ASSIGN expr ; .)
    }               reduce using rule 5 (varDecl -> VAR ID ASSIGN expr ; .)


state 100

    (36) for_stmt -> FOR ( for_asgn ; . for_lexpr ; for_asgn ) stmt
    (39) for_lexpr -> . empty
    (40) for_lexpr -> . lexpr
    (80) empty -> .
    (63) lexpr -> . lterm
    (64) lexpr -> . lexpr OR lterm
    (65) lterm -> . lfact
    (66) lterm -> . lterm AND lfact
    (67) lfact -> . FALSE
    (68) lfact -> . TRUE
    (69) lfact -> . NOT lfact
    (70) lfact -> . # ID [ aexpr ]
    (71) lfact -> . # ID
    (72) lfact -> . ( lexpr )
    (73) lfact -> . # call
    (74) lfact -> . cexpr
    (57) cexpr -> . aexpr LE aexpr
    (58) cexpr -> . aexpr LT aexpr
    (59) cexpr -> . aexpr GE aexpr
    (60) cexpr -> . aexpr GT aexpr
    (61) cexpr -> . aexpr NE aexpr
    (62) cexpr -> . aexpr EQ aexpr
    (45) aexpr -> . term
    (46) aexpr -> . aexpr MINUS term
    (47) aexpr -> . aexpr PLUS term
    (48) term -> . fact
    (49) term -> . term TIMES fact
    (50) term -> . term DIVIDE fact
    (51) fact -> . ID [ aexpr ]
    (52) fact -> . ID
    (53) fact -> . ( aexpr )
    (54) fact -> . NUMBER
    (55) fact -> . call
    (56) fact -> . MINUS fact
    (75) call -> . ID ( args )
    ;               reduce using rule 80 (empty -> .)
    FALSE           shift and go to state 36
    TRUE            shift and go to state 37
    NOT             shift and go to state 38
    #               shift and go to state 39
    (               shift and go to state 42
    ID              shift and go to state 40
    NUMBER          shift and go to state 48
    MINUS           shift and go to state 46

    for_lexpr                      shift and go to state 129
    empty                          shift and go to state 130
    lexpr                          shift and go to state 131
    lterm                          shift and go to state 34
    lfact                          shift and go to state 35
    aexpr                          shift and go to state 41
    call                           shift and go to state 43
    cexpr                          shift and go to state 44
    term                           shift and go to state 45
    fact                           shift and go to state 47

state 101

    (64) lexpr -> lexpr OR lterm .
    (66) lterm -> lterm . AND lfact
    OR              reduce using rule 64 (lexpr -> lexpr OR lterm .)
    {               reduce using rule 64 (lexpr -> lexpr OR lterm .)
    FOR             reduce using rule 64 (lexpr -> lexpr OR lterm .)
    WHILE           reduce using rule 64 (lexpr -> lexpr OR lterm .)
    IF              reduce using rule 64 (lexpr -> lexpr OR lterm .)
    RETURN          reduce using rule 64 (lexpr -> lexpr OR lterm .)
    PRINT           reduce using rule 64 (lexpr -> lexpr OR lterm .)
    ID              reduce using rule 64 (lexpr -> lexpr OR lterm .)
    ;               reduce using rule 64 (lexpr -> lexpr OR lterm .)
    )               reduce using rule 64 (lexpr -> lexpr OR lterm .)
    ]               reduce using rule 64 (lexpr -> lexpr OR lterm .)
    ,               reduce using rule 64 (lexpr -> lexpr OR lterm .)
    AND             shift and go to state 70


state 102

    (16) block -> { V . S }
    (3) V -> V . varDecl
    (17) S -> . S free_stmt
    (18) S -> . empty
    (4) varDecl -> . VAR ID ASSIGN [ Vexprs ] ;
    (5) varDecl -> . VAR ID ASSIGN expr ;
    (6) varDecl -> . VAR ID ;
    (80) empty -> .
    VAR             shift and go to state 7
    }               reduce using rule 80 (empty -> .)
    FOR             reduce using rule 80 (empty -> .)
    WHILE           reduce using rule 80 (empty -> .)
    IF              reduce using rule 80 (empty -> .)
    RETURN          reduce using rule 80 (empty -> .)
    PRINT           reduce using rule 80 (empty -> .)
    ID              reduce using rule 80 (empty -> .)

    S                              shift and go to state 132
    varDecl                        shift and go to state 5
    empty                          shift and go to state 10

state 103

    (66) lterm -> lterm AND lfact .
    AND             reduce using rule 66 (lterm -> lterm AND lfact .)
    OR              reduce using rule 66 (lterm -> lterm AND lfact .)
    {               reduce using rule 66 (lterm -> lterm AND lfact .)
    FOR             reduce using rule 66 (lterm -> lterm AND lfact .)
    WHILE           reduce using rule 66 (lterm -> lterm AND lfact .)
    IF              reduce using rule 66 (lterm -> lterm AND lfact .)
    RETURN          reduce using rule 66 (lterm -> lterm AND lfact .)
    PRINT           reduce using rule 66 (lterm -> lterm AND lfact .)
    ID              reduce using rule 66 (lterm -> lterm AND lfact .)
    ;               reduce using rule 66 (lterm -> lterm AND lfact .)
    )               reduce using rule 66 (lterm -> lterm AND lfact .)
    ]               reduce using rule 66 (lterm -> lterm AND lfact .)
    ,               reduce using rule 66 (lterm -> lterm AND lfact .)


state 104

    (70) lfact -> # ID [ . aexpr ]
    (45) aexpr -> . term
    (46) aexpr -> . aexpr MINUS term
    (47) aexpr -> . aexpr PLUS term
    (48) term -> . fact
    (49) term -> . term TIMES fact
    (50) term -> . term DIVIDE fact
    (51) fact -> . ID [ aexpr ]
    (52) fact -> . ID
    (53) fact -> . ( aexpr )
    (54) fact -> . NUMBER
    (55) fact -> . call
    (56) fact -> . MINUS fact
    (75) call -> . ID ( args )
    ID              shift and go to state 40
    (               shift and go to state 89
    NUMBER          shift and go to state 48
    MINUS           shift and go to state 46

    aexpr                          shift and go to state 133
    term                           shift and go to state 45
    fact                           shift and go to state 47
    call                           shift and go to state 43

state 105

    (51) fact -> ID [ aexpr . ]
    (46) aexpr -> aexpr . MINUS term
    (47) aexpr -> aexpr . PLUS term
    ]               shift and go to state 134
    MINUS           shift and go to state 82
    PLUS            shift and go to state 83


state 106

    (75) call -> ID ( args . )
    )               shift and go to state 135


state 107

    (76) args -> A .
    (78) A -> A . , expr
    )               reduce using rule 76 (args -> A .)
    ,               shift and go to state 136


state 108

    (77) args -> empty .
    )               reduce using rule 77 (args -> empty .)


state 109

    (79) A -> expr .
    ,               reduce using rule 79 (A -> expr .)
    )               reduce using rule 79 (A -> expr .)


state 110

    (57) cexpr -> aexpr LE aexpr .
    (46) aexpr -> aexpr . MINUS term
    (47) aexpr -> aexpr . PLUS term
    AND             reduce using rule 57 (cexpr -> aexpr LE aexpr .)
    OR              reduce using rule 57 (cexpr -> aexpr LE aexpr .)
    {               reduce using rule 57 (cexpr -> aexpr LE aexpr .)
    FOR             reduce using rule 57 (cexpr -> aexpr LE aexpr .)
    WHILE           reduce using rule 57 (cexpr -> aexpr LE aexpr .)
    IF              reduce using rule 57 (cexpr -> aexpr LE aexpr .)
    RETURN          reduce using rule 57 (cexpr -> aexpr LE aexpr .)
    PRINT           reduce using rule 57 (cexpr -> aexpr LE aexpr .)
    ID              reduce using rule 57 (cexpr -> aexpr LE aexpr .)
    ;               reduce using rule 57 (cexpr -> aexpr LE aexpr .)
    )               reduce using rule 57 (cexpr -> aexpr LE aexpr .)
    ]               reduce using rule 57 (cexpr -> aexpr LE aexpr .)
    ,               reduce using rule 57 (cexpr -> aexpr LE aexpr .)
    MINUS           shift and go to state 82
    PLUS            shift and go to state 83


state 111

    (58) cexpr -> aexpr LT aexpr .
    (46) aexpr -> aexpr . MINUS term
    (47) aexpr -> aexpr . PLUS term
    AND             reduce using rule 58 (cexpr -> aexpr LT aexpr .)
    OR              reduce using rule 58 (cexpr -> aexpr LT aexpr .)
    {               reduce using rule 58 (cexpr -> aexpr LT aexpr .)
    FOR             reduce using rule 58 (cexpr -> aexpr LT aexpr .)
    WHILE           reduce using rule 58 (cexpr -> aexpr LT aexpr .)
    IF              reduce using rule 58 (cexpr -> aexpr LT aexpr .)
    RETURN          reduce using rule 58 (cexpr -> aexpr LT aexpr .)
    PRINT           reduce using rule 58 (cexpr -> aexpr LT aexpr .)
    ID              reduce using rule 58 (cexpr -> aexpr LT aexpr .)
    ;               reduce using rule 58 (cexpr -> aexpr LT aexpr .)
    )               reduce using rule 58 (cexpr -> aexpr LT aexpr .)
    ]               reduce using rule 58 (cexpr -> aexpr LT aexpr .)
    ,               reduce using rule 58 (cexpr -> aexpr LT aexpr .)
    MINUS           shift and go to state 82
    PLUS            shift and go to state 83


state 112

    (59) cexpr -> aexpr GE aexpr .
    (46) aexpr -> aexpr . MINUS term
    (47) aexpr -> aexpr . PLUS term
    AND             reduce using rule 59 (cexpr -> aexpr GE aexpr .)
    OR              reduce using rule 59 (cexpr -> aexpr GE aexpr .)
    {               reduce using rule 59 (cexpr -> aexpr GE aexpr .)
    FOR             reduce using rule 59 (cexpr -> aexpr GE aexpr .)
    WHILE           reduce using rule 59 (cexpr -> aexpr GE aexpr .)
    IF              reduce using rule 59 (cexpr -> aexpr GE aexpr .)
    RETURN          reduce using rule 59 (cexpr -> aexpr GE aexpr .)
    PRINT           reduce using rule 59 (cexpr -> aexpr GE aexpr .)
    ID              reduce using rule 59 (cexpr -> aexpr GE aexpr .)
    ;               reduce using rule 59 (cexpr -> aexpr GE aexpr .)
    )               reduce using rule 59 (cexpr -> aexpr GE aexpr .)
    ]               reduce using rule 59 (cexpr -> aexpr GE aexpr .)
    ,               reduce using rule 59 (cexpr -> aexpr GE aexpr .)
    MINUS           shift and go to state 82
    PLUS            shift and go to state 83


state 113

    (60) cexpr -> aexpr GT aexpr .
    (46) aexpr -> aexpr . MINUS term
    (47) aexpr -> aexpr . PLUS term
    AND             reduce using rule 60 (cexpr -> aexpr GT aexpr .)
    OR              reduce using rule 60 (cexpr -> aexpr GT aexpr .)
    {               reduce using rule 60 (cexpr -> aexpr GT aexpr .)
    FOR             reduce using rule 60 (cexpr -> aexpr GT aexpr .)
    WHILE           reduce using rule 60 (cexpr -> aexpr GT aexpr .)
    IF              reduce using rule 60 (cexpr -> aexpr GT aexpr .)
    RETURN          reduce using rule 60 (cexpr -> aexpr GT aexpr .)
    PRINT           reduce using rule 60 (cexpr -> aexpr GT aexpr .)
    ID              reduce using rule 60 (cexpr -> aexpr GT aexpr .)
    ;               reduce using rule 60 (cexpr -> aexpr GT aexpr .)
    )               reduce using rule 60 (cexpr -> aexpr GT aexpr .)
    ]               reduce using rule 60 (cexpr -> aexpr GT aexpr .)
    ,               reduce using rule 60 (cexpr -> aexpr GT aexpr .)
    MINUS           shift and go to state 82
    PLUS            shift and go to state 83


state 114

    (61) cexpr -> aexpr NE aexpr .
    (46) aexpr -> aexpr . MINUS term
    (47) aexpr -> aexpr . PLUS term
    AND             reduce using rule 61 (cexpr -> aexpr NE aexpr .)
    OR              reduce using rule 61 (cexpr -> aexpr NE aexpr .)
    {               reduce using rule 61 (cexpr -> aexpr NE aexpr .)
    FOR             reduce using rule 61 (cexpr -> aexpr NE aexpr .)
    WHILE           reduce using rule 61 (cexpr -> aexpr NE aexpr .)
    IF              reduce using rule 61 (cexpr -> aexpr NE aexpr .)
    RETURN          reduce using rule 61 (cexpr -> aexpr NE aexpr .)
    PRINT           reduce using rule 61 (cexpr -> aexpr NE aexpr .)
    ID              reduce using rule 61 (cexpr -> aexpr NE aexpr .)
    ;               reduce using rule 61 (cexpr -> aexpr NE aexpr .)
    )               reduce using rule 61 (cexpr -> aexpr NE aexpr .)
    ]               reduce using rule 61 (cexpr -> aexpr NE aexpr .)
    ,               reduce using rule 61 (cexpr -> aexpr NE aexpr .)
    MINUS           shift and go to state 82
    PLUS            shift and go to state 83


state 115

    (62) cexpr -> aexpr EQ aexpr .
    (46) aexpr -> aexpr . MINUS term
    (47) aexpr -> aexpr . PLUS term
    AND             reduce using rule 62 (cexpr -> aexpr EQ aexpr .)
    OR              reduce using rule 62 (cexpr -> aexpr EQ aexpr .)
    {               reduce using rule 62 (cexpr -> aexpr EQ aexpr .)
    FOR             reduce using rule 62 (cexpr -> aexpr EQ aexpr .)
    WHILE           reduce using rule 62 (cexpr -> aexpr EQ aexpr .)
    IF              reduce using rule 62 (cexpr -> aexpr EQ aexpr .)
    RETURN          reduce using rule 62 (cexpr -> aexpr EQ aexpr .)
    PRINT           reduce using rule 62 (cexpr -> aexpr EQ aexpr .)
    ID              reduce using rule 62 (cexpr -> aexpr EQ aexpr .)
    ;               reduce using rule 62 (cexpr -> aexpr EQ aexpr .)
    )               reduce using rule 62 (cexpr -> aexpr EQ aexpr .)
    ]               reduce using rule 62 (cexpr -> aexpr EQ aexpr .)
    ,               reduce using rule 62 (cexpr -> aexpr EQ aexpr .)
    MINUS           shift and go to state 82
    PLUS            shift and go to state 83


state 116

    (46) aexpr -> aexpr MINUS term .
    (49) term -> term . TIMES fact
    (50) term -> term . DIVIDE fact
    LE              reduce using rule 46 (aexpr -> aexpr MINUS term .)
    LT              reduce using rule 46 (aexpr -> aexpr MINUS term .)
    GE              reduce using rule 46 (aexpr -> aexpr MINUS term .)
    GT              reduce using rule 46 (aexpr -> aexpr MINUS term .)
    NE              reduce using rule 46 (aexpr -> aexpr MINUS term .)
    EQ              reduce using rule 46 (aexpr -> aexpr MINUS term .)
    MINUS           reduce using rule 46 (aexpr -> aexpr MINUS term .)
    PLUS            reduce using rule 46 (aexpr -> aexpr MINUS term .)
    ;               reduce using rule 46 (aexpr -> aexpr MINUS term .)
    )               reduce using rule 46 (aexpr -> aexpr MINUS term .)
    ]               reduce using rule 46 (aexpr -> aexpr MINUS term .)
    ,               reduce using rule 46 (aexpr -> aexpr MINUS term .)
    AND             reduce using rule 46 (aexpr -> aexpr MINUS term .)
    OR              reduce using rule 46 (aexpr -> aexpr MINUS term .)
    {               reduce using rule 46 (aexpr -> aexpr MINUS term .)
    FOR             reduce using rule 46 (aexpr -> aexpr MINUS term .)
    WHILE           reduce using rule 46 (aexpr -> aexpr MINUS term .)
    IF              reduce using rule 46 (aexpr -> aexpr MINUS term .)
    RETURN          reduce using rule 46 (aexpr -> aexpr MINUS term .)
    PRINT           reduce using rule 46 (aexpr -> aexpr MINUS term .)
    ID              reduce using rule 46 (aexpr -> aexpr MINUS term .)
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87


state 117

    (47) aexpr -> aexpr PLUS term .
    (49) term -> term . TIMES fact
    (50) term -> term . DIVIDE fact
    LE              reduce using rule 47 (aexpr -> aexpr PLUS term .)
    LT              reduce using rule 47 (aexpr -> aexpr PLUS term .)
    GE              reduce using rule 47 (aexpr -> aexpr PLUS term .)
    GT              reduce using rule 47 (aexpr -> aexpr PLUS term .)
    NE              reduce using rule 47 (aexpr -> aexpr PLUS term .)
    EQ              reduce using rule 47 (aexpr -> aexpr PLUS term .)
    MINUS           reduce using rule 47 (aexpr -> aexpr PLUS term .)
    PLUS            reduce using rule 47 (aexpr -> aexpr PLUS term .)
    ;               reduce using rule 47 (aexpr -> aexpr PLUS term .)
    )               reduce using rule 47 (aexpr -> aexpr PLUS term .)
    ]               reduce using rule 47 (aexpr -> aexpr PLUS term .)
    ,               reduce using rule 47 (aexpr -> aexpr PLUS term .)
    AND             reduce using rule 47 (aexpr -> aexpr PLUS term .)
    OR              reduce using rule 47 (aexpr -> aexpr PLUS term .)
    {               reduce using rule 47 (aexpr -> aexpr PLUS term .)
    FOR             reduce using rule 47 (aexpr -> aexpr PLUS term .)
    WHILE           reduce using rule 47 (aexpr -> aexpr PLUS term .)
    IF              reduce using rule 47 (aexpr -> aexpr PLUS term .)
    RETURN          reduce using rule 47 (aexpr -> aexpr PLUS term .)
    PRINT           reduce using rule 47 (aexpr -> aexpr PLUS term .)
    ID              reduce using rule 47 (aexpr -> aexpr PLUS term .)
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87


state 118

    (72) lfact -> ( lexpr ) .
    AND             reduce using rule 72 (lfact -> ( lexpr ) .)
    OR              reduce using rule 72 (lfact -> ( lexpr ) .)
    {               reduce using rule 72 (lfact -> ( lexpr ) .)
    FOR             reduce using rule 72 (lfact -> ( lexpr ) .)
    WHILE           reduce using rule 72 (lfact -> ( lexpr ) .)
    IF              reduce using rule 72 (lfact -> ( lexpr ) .)
    RETURN          reduce using rule 72 (lfact -> ( lexpr ) .)
    PRINT           reduce using rule 72 (lfact -> ( lexpr ) .)
    ID              reduce using rule 72 (lfact -> ( lexpr ) .)
    ;               reduce using rule 72 (lfact -> ( lexpr ) .)
    )               reduce using rule 72 (lfact -> ( lexpr ) .)
    ]               reduce using rule 72 (lfact -> ( lexpr ) .)
    ,               reduce using rule 72 (lfact -> ( lexpr ) .)


state 119

    (53) fact -> ( aexpr ) .
    TIMES           reduce using rule 53 (fact -> ( aexpr ) .)
    DIVIDE          reduce using rule 53 (fact -> ( aexpr ) .)
    LE              reduce using rule 53 (fact -> ( aexpr ) .)
    LT              reduce using rule 53 (fact -> ( aexpr ) .)
    GE              reduce using rule 53 (fact -> ( aexpr ) .)
    GT              reduce using rule 53 (fact -> ( aexpr ) .)
    NE              reduce using rule 53 (fact -> ( aexpr ) .)
    EQ              reduce using rule 53 (fact -> ( aexpr ) .)
    MINUS           reduce using rule 53 (fact -> ( aexpr ) .)
    PLUS            reduce using rule 53 (fact -> ( aexpr ) .)
    ;               reduce using rule 53 (fact -> ( aexpr ) .)
    )               reduce using rule 53 (fact -> ( aexpr ) .)
    ]               reduce using rule 53 (fact -> ( aexpr ) .)
    ,               reduce using rule 53 (fact -> ( aexpr ) .)
    AND             reduce using rule 53 (fact -> ( aexpr ) .)
    OR              reduce using rule 53 (fact -> ( aexpr ) .)
    {               reduce using rule 53 (fact -> ( aexpr ) .)
    FOR             reduce using rule 53 (fact -> ( aexpr ) .)
    WHILE           reduce using rule 53 (fact -> ( aexpr ) .)
    IF              reduce using rule 53 (fact -> ( aexpr ) .)
    RETURN          reduce using rule 53 (fact -> ( aexpr ) .)
    PRINT           reduce using rule 53 (fact -> ( aexpr ) .)
    ID              reduce using rule 53 (fact -> ( aexpr ) .)


state 120

    (49) term -> term TIMES fact .
    TIMES           reduce using rule 49 (term -> term TIMES fact .)
    DIVIDE          reduce using rule 49 (term -> term TIMES fact .)
    LE              reduce using rule 49 (term -> term TIMES fact .)
    LT              reduce using rule 49 (term -> term TIMES fact .)
    GE              reduce using rule 49 (term -> term TIMES fact .)
    GT              reduce using rule 49 (term -> term TIMES fact .)
    NE              reduce using rule 49 (term -> term TIMES fact .)
    EQ              reduce using rule 49 (term -> term TIMES fact .)
    MINUS           reduce using rule 49 (term -> term TIMES fact .)
    PLUS            reduce using rule 49 (term -> term TIMES fact .)
    ;               reduce using rule 49 (term -> term TIMES fact .)
    )               reduce using rule 49 (term -> term TIMES fact .)
    ]               reduce using rule 49 (term -> term TIMES fact .)
    ,               reduce using rule 49 (term -> term TIMES fact .)
    AND             reduce using rule 49 (term -> term TIMES fact .)
    OR              reduce using rule 49 (term -> term TIMES fact .)
    {               reduce using rule 49 (term -> term TIMES fact .)
    FOR             reduce using rule 49 (term -> term TIMES fact .)
    WHILE           reduce using rule 49 (term -> term TIMES fact .)
    IF              reduce using rule 49 (term -> term TIMES fact .)
    RETURN          reduce using rule 49 (term -> term TIMES fact .)
    PRINT           reduce using rule 49 (term -> term TIMES fact .)
    ID              reduce using rule 49 (term -> term TIMES fact .)


state 121

    (50) term -> term DIVIDE fact .
    TIMES           reduce using rule 50 (term -> term DIVIDE fact .)
    DIVIDE          reduce using rule 50 (term -> term DIVIDE fact .)
    LE              reduce using rule 50 (term -> term DIVIDE fact .)
    LT              reduce using rule 50 (term -> term DIVIDE fact .)
    GE              reduce using rule 50 (term -> term DIVIDE fact .)
    GT              reduce using rule 50 (term -> term DIVIDE fact .)
    NE              reduce using rule 50 (term -> term DIVIDE fact .)
    EQ              reduce using rule 50 (term -> term DIVIDE fact .)
    MINUS           reduce using rule 50 (term -> term DIVIDE fact .)
    PLUS            reduce using rule 50 (term -> term DIVIDE fact .)
    ;               reduce using rule 50 (term -> term DIVIDE fact .)
    )               reduce using rule 50 (term -> term DIVIDE fact .)
    ]               reduce using rule 50 (term -> term DIVIDE fact .)
    ,               reduce using rule 50 (term -> term DIVIDE fact .)
    AND             reduce using rule 50 (term -> term DIVIDE fact .)
    OR              reduce using rule 50 (term -> term DIVIDE fact .)
    {               reduce using rule 50 (term -> term DIVIDE fact .)
    FOR             reduce using rule 50 (term -> term DIVIDE fact .)
    WHILE           reduce using rule 50 (term -> term DIVIDE fact .)
    IF              reduce using rule 50 (term -> term DIVIDE fact .)
    RETURN          reduce using rule 50 (term -> term DIVIDE fact .)
    PRINT           reduce using rule 50 (term -> term DIVIDE fact .)
    ID              reduce using rule 50 (term -> term DIVIDE fact .)


state 122

    (53) fact -> ( aexpr . )
    (46) aexpr -> aexpr . MINUS term
    (47) aexpr -> aexpr . PLUS term
    )               shift and go to state 119
    MINUS           shift and go to state 82
    PLUS            shift and go to state 83


state 123

    (33) if_stmt -> IF lexpr stmt ELSE . stmt
    (19) stmt -> . block
    (20) stmt -> . free_stmt
    (16) block -> . { V S }
    (21) free_stmt -> . compound_stmt
    (22) free_stmt -> . simple_stmt ;
    (30) compound_stmt -> . for_stmt
    (31) compound_stmt -> . while_stmt
    (32) compound_stmt -> . if_stmt
    (25) simple_stmt -> . return_stmt
    (26) simple_stmt -> . print_stmt
    (27) simple_stmt -> . asgn_stmt
    (36) for_stmt -> . FOR ( for_asgn ; for_lexpr ; for_asgn ) stmt
    (35) while_stmt -> . WHILE lexpr stmt
    (33) if_stmt -> . IF lexpr stmt ELSE stmt
    (34) if_stmt -> . IF lexpr stmt
    (29) return_stmt -> . RETURN expr
    (28) print_stmt -> . PRINT expr
    (23) asgn_stmt -> . ID [ aexpr ] ASSIGN expr
    (24) asgn_stmt -> . ID ASSIGN expr
    {               shift and go to state 69
    FOR             shift and go to state 22
    WHILE           shift and go to state 23
    IF              shift and go to state 24
    RETURN          shift and go to state 25
    PRINT           shift and go to state 26
    ID              shift and go to state 27

    stmt                           shift and go to state 137
    block                          shift and go to state 67
    free_stmt                      shift and go to state 68
    compound_stmt                  shift and go to state 14
    simple_stmt                    shift and go to state 15
    for_stmt                       shift and go to state 16
    while_stmt                     shift and go to state 17
    if_stmt                        shift and go to state 18
    return_stmt                    shift and go to state 19
    print_stmt                     shift and go to state 20
    asgn_stmt                      shift and go to state 21

state 124

    (23) asgn_stmt -> ID [ aexpr ] . ASSIGN expr
    ASSIGN          shift and go to state 138


state 125

    (11) funDecl -> FUN ID ( parameters ) . block
    (16) block -> . { V S }
    {               shift and go to state 69

    block                          shift and go to state 139

state 126

    (14) P -> P , . ID
    ID              shift and go to state 140


state 127

    (4) varDecl -> VAR ID ASSIGN [ Vexprs ] . ;
    ;               shift and go to state 141


state 128

    (8) Vexprs -> Vexprs , . expr
    (41) expr -> . aexpr
    (42) expr -> . sexpr
    (43) expr -> . lexpr
    (45) aexpr -> . term
    (46) aexpr -> . aexpr MINUS term
    (47) aexpr -> . aexpr PLUS term
    (44) sexpr -> . STRING
    (63) lexpr -> . lterm
    (64) lexpr -> . lexpr OR lterm
    (48) term -> . fact
    (49) term -> . term TIMES fact
    (50) term -> . term DIVIDE fact
    (65) lterm -> . lfact
    (66) lterm -> . lterm AND lfact
    (51) fact -> . ID [ aexpr ]
    (52) fact -> . ID
    (53) fact -> . ( aexpr )
    (54) fact -> . NUMBER
    (55) fact -> . call
    (56) fact -> . MINUS fact
    (67) lfact -> . FALSE
    (68) lfact -> . TRUE
    (69) lfact -> . NOT lfact
    (70) lfact -> . # ID [ aexpr ]
    (71) lfact -> . # ID
    (72) lfact -> . ( lexpr )
    (73) lfact -> . # call
    (74) lfact -> . cexpr
    (75) call -> . ID ( args )
    (57) cexpr -> . aexpr LE aexpr
    (58) cexpr -> . aexpr LT aexpr
    (59) cexpr -> . aexpr GE aexpr
    (60) cexpr -> . aexpr GT aexpr
    (61) cexpr -> . aexpr NE aexpr
    (62) cexpr -> . aexpr EQ aexpr
    STRING          shift and go to state 54
    ID              shift and go to state 40
    (               shift and go to state 55
    NUMBER          shift and go to state 48
    MINUS           shift and go to state 46
    FALSE           shift and go to state 36
    TRUE            shift and go to state 37
    NOT             shift and go to state 38
    #               shift and go to state 39

    expr                           shift and go to state 142
    aexpr                          shift and go to state 51
    sexpr                          shift and go to state 52
    lexpr                          shift and go to state 53
    term                           shift and go to state 45
    lterm                          shift and go to state 34
    fact                           shift and go to state 47
    lfact                          shift and go to state 35
    call                           shift and go to state 43
    cexpr                          shift and go to state 44

state 129

    (36) for_stmt -> FOR ( for_asgn ; for_lexpr . ; for_asgn ) stmt
    ;               shift and go to state 143


state 130

    (39) for_lexpr -> empty .
    ;               reduce using rule 39 (for_lexpr -> empty .)


state 131

    (40) for_lexpr -> lexpr .
    (64) lexpr -> lexpr . OR lterm
    ;               reduce using rule 40 (for_lexpr -> lexpr .)
    OR              shift and go to state 66


state 132

    (16) block -> { V S . }
    (17) S -> S . free_stmt
    (21) free_stmt -> . compound_stmt
    (22) free_stmt -> . simple_stmt ;
    (30) compound_stmt -> . for_stmt
    (31) compound_stmt -> . while_stmt
    (32) compound_stmt -> . if_stmt
    (25) simple_stmt -> . return_stmt
    (26) simple_stmt -> . print_stmt
    (27) simple_stmt -> . asgn_stmt
    (36) for_stmt -> . FOR ( for_asgn ; for_lexpr ; for_asgn ) stmt
    (35) while_stmt -> . WHILE lexpr stmt
    (33) if_stmt -> . IF lexpr stmt ELSE stmt
    (34) if_stmt -> . IF lexpr stmt
    (29) return_stmt -> . RETURN expr
    (28) print_stmt -> . PRINT expr
    (23) asgn_stmt -> . ID [ aexpr ] ASSIGN expr
    (24) asgn_stmt -> . ID ASSIGN expr
    }               shift and go to state 144
    FOR             shift and go to state 22
    WHILE           shift and go to state 23
    IF              shift and go to state 24
    RETURN          shift and go to state 25
    PRINT           shift and go to state 26
    ID              shift and go to state 27

    free_stmt                      shift and go to state 13
    compound_stmt                  shift and go to state 14
    simple_stmt                    shift and go to state 15
    for_stmt                       shift and go to state 16
    while_stmt                     shift and go to state 17
    if_stmt                        shift and go to state 18
    return_stmt                    shift and go to state 19
    print_stmt                     shift and go to state 20
    asgn_stmt                      shift and go to state 21

state 133

    (70) lfact -> # ID [ aexpr . ]
    (46) aexpr -> aexpr . MINUS term
    (47) aexpr -> aexpr . PLUS term
    ]               shift and go to state 145
    MINUS           shift and go to state 82
    PLUS            shift and go to state 83


state 134

    (51) fact -> ID [ aexpr ] .
    TIMES           reduce using rule 51 (fact -> ID [ aexpr ] .)
    DIVIDE          reduce using rule 51 (fact -> ID [ aexpr ] .)
    LE              reduce using rule 51 (fact -> ID [ aexpr ] .)
    LT              reduce using rule 51 (fact -> ID [ aexpr ] .)
    GE              reduce using rule 51 (fact -> ID [ aexpr ] .)
    GT              reduce using rule 51 (fact -> ID [ aexpr ] .)
    NE              reduce using rule 51 (fact -> ID [ aexpr ] .)
    EQ              reduce using rule 51 (fact -> ID [ aexpr ] .)
    MINUS           reduce using rule 51 (fact -> ID [ aexpr ] .)
    PLUS            reduce using rule 51 (fact -> ID [ aexpr ] .)
    ;               reduce using rule 51 (fact -> ID [ aexpr ] .)
    )               reduce using rule 51 (fact -> ID [ aexpr ] .)
    ]               reduce using rule 51 (fact -> ID [ aexpr ] .)
    ,               reduce using rule 51 (fact -> ID [ aexpr ] .)
    AND             reduce using rule 51 (fact -> ID [ aexpr ] .)
    OR              reduce using rule 51 (fact -> ID [ aexpr ] .)
    {               reduce using rule 51 (fact -> ID [ aexpr ] .)
    FOR             reduce using rule 51 (fact -> ID [ aexpr ] .)
    WHILE           reduce using rule 51 (fact -> ID [ aexpr ] .)
    IF              reduce using rule 51 (fact -> ID [ aexpr ] .)
    RETURN          reduce using rule 51 (fact -> ID [ aexpr ] .)
    PRINT           reduce using rule 51 (fact -> ID [ aexpr ] .)
    ID              reduce using rule 51 (fact -> ID [ aexpr ] .)


state 135

    (75) call -> ID ( args ) .
    TIMES           reduce using rule 75 (call -> ID ( args ) .)
    DIVIDE          reduce using rule 75 (call -> ID ( args ) .)
    LE              reduce using rule 75 (call -> ID ( args ) .)
    LT              reduce using rule 75 (call -> ID ( args ) .)
    GE              reduce using rule 75 (call -> ID ( args ) .)
    GT              reduce using rule 75 (call -> ID ( args ) .)
    NE              reduce using rule 75 (call -> ID ( args ) .)
    EQ              reduce using rule 75 (call -> ID ( args ) .)
    MINUS           reduce using rule 75 (call -> ID ( args ) .)
    PLUS            reduce using rule 75 (call -> ID ( args ) .)
    ;               reduce using rule 75 (call -> ID ( args ) .)
    AND             reduce using rule 75 (call -> ID ( args ) .)
    OR              reduce using rule 75 (call -> ID ( args ) .)
    {               reduce using rule 75 (call -> ID ( args ) .)
    FOR             reduce using rule 75 (call -> ID ( args ) .)
    WHILE           reduce using rule 75 (call -> ID ( args ) .)
    IF              reduce using rule 75 (call -> ID ( args ) .)
    RETURN          reduce using rule 75 (call -> ID ( args ) .)
    PRINT           reduce using rule 75 (call -> ID ( args ) .)
    ID              reduce using rule 75 (call -> ID ( args ) .)
    )               reduce using rule 75 (call -> ID ( args ) .)
    ]               reduce using rule 75 (call -> ID ( args ) .)
    ,               reduce using rule 75 (call -> ID ( args ) .)


state 136

    (78) A -> A , . expr
    (41) expr -> . aexpr
    (42) expr -> . sexpr
    (43) expr -> . lexpr
    (45) aexpr -> . term
    (46) aexpr -> . aexpr MINUS term
    (47) aexpr -> . aexpr PLUS term
    (44) sexpr -> . STRING
    (63) lexpr -> . lterm
    (64) lexpr -> . lexpr OR lterm
    (48) term -> . fact
    (49) term -> . term TIMES fact
    (50) term -> . term DIVIDE fact
    (65) lterm -> . lfact
    (66) lterm -> . lterm AND lfact
    (51) fact -> . ID [ aexpr ]
    (52) fact -> . ID
    (53) fact -> . ( aexpr )
    (54) fact -> . NUMBER
    (55) fact -> . call
    (56) fact -> . MINUS fact
    (67) lfact -> . FALSE
    (68) lfact -> . TRUE
    (69) lfact -> . NOT lfact
    (70) lfact -> . # ID [ aexpr ]
    (71) lfact -> . # ID
    (72) lfact -> . ( lexpr )
    (73) lfact -> . # call
    (74) lfact -> . cexpr
    (75) call -> . ID ( args )
    (57) cexpr -> . aexpr LE aexpr
    (58) cexpr -> . aexpr LT aexpr
    (59) cexpr -> . aexpr GE aexpr
    (60) cexpr -> . aexpr GT aexpr
    (61) cexpr -> . aexpr NE aexpr
    (62) cexpr -> . aexpr EQ aexpr
    STRING          shift and go to state 54
    ID              shift and go to state 40
    (               shift and go to state 55
    NUMBER          shift and go to state 48
    MINUS           shift and go to state 46
    FALSE           shift and go to state 36
    TRUE            shift and go to state 37
    NOT             shift and go to state 38
    #               shift and go to state 39

    expr                           shift and go to state 146
    aexpr                          shift and go to state 51
    sexpr                          shift and go to state 52
    lexpr                          shift and go to state 53
    term                           shift and go to state 45
    lterm                          shift and go to state 34
    fact                           shift and go to state 47
    lfact                          shift and go to state 35
    call                           shift and go to state 43
    cexpr                          shift and go to state 44

state 137

    (33) if_stmt -> IF lexpr stmt ELSE stmt .
    FOR             reduce using rule 33 (if_stmt -> IF lexpr stmt ELSE stmt .)
    WHILE           reduce using rule 33 (if_stmt -> IF lexpr stmt ELSE stmt .)
    IF              reduce using rule 33 (if_stmt -> IF lexpr stmt ELSE stmt .)
    RETURN          reduce using rule 33 (if_stmt -> IF lexpr stmt ELSE stmt .)
    PRINT           reduce using rule 33 (if_stmt -> IF lexpr stmt ELSE stmt .)
    ID              reduce using rule 33 (if_stmt -> IF lexpr stmt ELSE stmt .)
    $end            reduce using rule 33 (if_stmt -> IF lexpr stmt ELSE stmt .)
    ELSE            reduce using rule 33 (if_stmt -> IF lexpr stmt ELSE stmt .)
    }               reduce using rule 33 (if_stmt -> IF lexpr stmt ELSE stmt .)


state 138

    (23) asgn_stmt -> ID [ aexpr ] ASSIGN . expr
    (41) expr -> . aexpr
    (42) expr -> . sexpr
    (43) expr -> . lexpr
    (45) aexpr -> . term
    (46) aexpr -> . aexpr MINUS term
    (47) aexpr -> . aexpr PLUS term
    (44) sexpr -> . STRING
    (63) lexpr -> . lterm
    (64) lexpr -> . lexpr OR lterm
    (48) term -> . fact
    (49) term -> . term TIMES fact
    (50) term -> . term DIVIDE fact
    (65) lterm -> . lfact
    (66) lterm -> . lterm AND lfact
    (51) fact -> . ID [ aexpr ]
    (52) fact -> . ID
    (53) fact -> . ( aexpr )
    (54) fact -> . NUMBER
    (55) fact -> . call
    (56) fact -> . MINUS fact
    (67) lfact -> . FALSE
    (68) lfact -> . TRUE
    (69) lfact -> . NOT lfact
    (70) lfact -> . # ID [ aexpr ]
    (71) lfact -> . # ID
    (72) lfact -> . ( lexpr )
    (73) lfact -> . # call
    (74) lfact -> . cexpr
    (75) call -> . ID ( args )
    (57) cexpr -> . aexpr LE aexpr
    (58) cexpr -> . aexpr LT aexpr
    (59) cexpr -> . aexpr GE aexpr
    (60) cexpr -> . aexpr GT aexpr
    (61) cexpr -> . aexpr NE aexpr
    (62) cexpr -> . aexpr EQ aexpr
    STRING          shift and go to state 54
    ID              shift and go to state 40
    (               shift and go to state 55
    NUMBER          shift and go to state 48
    MINUS           shift and go to state 46
    FALSE           shift and go to state 36
    TRUE            shift and go to state 37
    NOT             shift and go to state 38
    #               shift and go to state 39

    aexpr                          shift and go to state 51
    expr                           shift and go to state 147
    sexpr                          shift and go to state 52
    lexpr                          shift and go to state 53
    term                           shift and go to state 45
    lterm                          shift and go to state 34
    fact                           shift and go to state 47
    lfact                          shift and go to state 35
    call                           shift and go to state 43
    cexpr                          shift and go to state 44

state 139

    (11) funDecl -> FUN ID ( parameters ) block .
    FUN             reduce using rule 11 (funDecl -> FUN ID ( parameters ) block .)
    FOR             reduce using rule 11 (funDecl -> FUN ID ( parameters ) block .)
    WHILE           reduce using rule 11 (funDecl -> FUN ID ( parameters ) block .)
    IF              reduce using rule 11 (funDecl -> FUN ID ( parameters ) block .)
    RETURN          reduce using rule 11 (funDecl -> FUN ID ( parameters ) block .)
    PRINT           reduce using rule 11 (funDecl -> FUN ID ( parameters ) block .)
    ID              reduce using rule 11 (funDecl -> FUN ID ( parameters ) block .)
    $end            reduce using rule 11 (funDecl -> FUN ID ( parameters ) block .)


state 140

    (14) P -> P , ID .
    ,               reduce using rule 14 (P -> P , ID .)
    )               reduce using rule 14 (P -> P , ID .)


state 141

    (4) varDecl -> VAR ID ASSIGN [ Vexprs ] ; .
    VAR             reduce using rule 4 (varDecl -> VAR ID ASSIGN [ Vexprs ] ; .)
    FUN             reduce using rule 4 (varDecl -> VAR ID ASSIGN [ Vexprs ] ; .)
    FOR             reduce using rule 4 (varDecl -> VAR ID ASSIGN [ Vexprs ] ; .)
    WHILE           reduce using rule 4 (varDecl -> VAR ID ASSIGN [ Vexprs ] ; .)
    IF              reduce using rule 4 (varDecl -> VAR ID ASSIGN [ Vexprs ] ; .)
    RETURN          reduce using rule 4 (varDecl -> VAR ID ASSIGN [ Vexprs ] ; .)
    PRINT           reduce using rule 4 (varDecl -> VAR ID ASSIGN [ Vexprs ] ; .)
    ID              reduce using rule 4 (varDecl -> VAR ID ASSIGN [ Vexprs ] ; .)
    $end            reduce using rule 4 (varDecl -> VAR ID ASSIGN [ Vexprs ] ; .)
    }               reduce using rule 4 (varDecl -> VAR ID ASSIGN [ Vexprs ] ; .)


state 142

    (8) Vexprs -> Vexprs , expr .
    ]               reduce using rule 8 (Vexprs -> Vexprs , expr .)
    ,               reduce using rule 8 (Vexprs -> Vexprs , expr .)


state 143

    (36) for_stmt -> FOR ( for_asgn ; for_lexpr ; . for_asgn ) stmt
    (37) for_asgn -> . empty
    (38) for_asgn -> . asgn_stmt
    (80) empty -> .
    (23) asgn_stmt -> . ID [ aexpr ] ASSIGN expr
    (24) asgn_stmt -> . ID ASSIGN expr
    )               reduce using rule 80 (empty -> .)
    ID              shift and go to state 27

    for_asgn                       shift and go to state 148
    empty                          shift and go to state 63
    asgn_stmt                      shift and go to state 64

state 144

    (16) block -> { V S } .
    FOR             reduce using rule 16 (block -> { V S } .)
    WHILE           reduce using rule 16 (block -> { V S } .)
    IF              reduce using rule 16 (block -> { V S } .)
    RETURN          reduce using rule 16 (block -> { V S } .)
    PRINT           reduce using rule 16 (block -> { V S } .)
    ID              reduce using rule 16 (block -> { V S } .)
    $end            reduce using rule 16 (block -> { V S } .)
    ELSE            reduce using rule 16 (block -> { V S } .)
    }               reduce using rule 16 (block -> { V S } .)
    FUN             reduce using rule 16 (block -> { V S } .)


state 145

    (70) lfact -> # ID [ aexpr ] .
    AND             reduce using rule 70 (lfact -> # ID [ aexpr ] .)
    OR              reduce using rule 70 (lfact -> # ID [ aexpr ] .)
    {               reduce using rule 70 (lfact -> # ID [ aexpr ] .)
    FOR             reduce using rule 70 (lfact -> # ID [ aexpr ] .)
    WHILE           reduce using rule 70 (lfact -> # ID [ aexpr ] .)
    IF              reduce using rule 70 (lfact -> # ID [ aexpr ] .)
    RETURN          reduce using rule 70 (lfact -> # ID [ aexpr ] .)
    PRINT           reduce using rule 70 (lfact -> # ID [ aexpr ] .)
    ID              reduce using rule 70 (lfact -> # ID [ aexpr ] .)
    ;               reduce using rule 70 (lfact -> # ID [ aexpr ] .)
    )               reduce using rule 70 (lfact -> # ID [ aexpr ] .)
    ]               reduce using rule 70 (lfact -> # ID [ aexpr ] .)
    ,               reduce using rule 70 (lfact -> # ID [ aexpr ] .)


state 146

    (78) A -> A , expr .
    ,               reduce using rule 78 (A -> A , expr .)
    )               reduce using rule 78 (A -> A , expr .)


state 147

    (23) asgn_stmt -> ID [ aexpr ] ASSIGN expr .
    ;               reduce using rule 23 (asgn_stmt -> ID [ aexpr ] ASSIGN expr .)
    )               reduce using rule 23 (asgn_stmt -> ID [ aexpr ] ASSIGN expr .)


state 148

    (36) for_stmt -> FOR ( for_asgn ; for_lexpr ; for_asgn . ) stmt
    )               shift and go to state 149


state 149

    (36) for_stmt -> FOR ( for_asgn ; for_lexpr ; for_asgn ) . stmt
    (19) stmt -> . block
    (20) stmt -> . free_stmt
    (16) block -> . { V S }
    (21) free_stmt -> . compound_stmt
    (22) free_stmt -> . simple_stmt ;
    (30) compound_stmt -> . for_stmt
    (31) compound_stmt -> . while_stmt
    (32) compound_stmt -> . if_stmt
    (25) simple_stmt -> . return_stmt
    (26) simple_stmt -> . print_stmt
    (27) simple_stmt -> . asgn_stmt
    (36) for_stmt -> . FOR ( for_asgn ; for_lexpr ; for_asgn ) stmt
    (35) while_stmt -> . WHILE lexpr stmt
    (33) if_stmt -> . IF lexpr stmt ELSE stmt
    (34) if_stmt -> . IF lexpr stmt
    (29) return_stmt -> . RETURN expr
    (28) print_stmt -> . PRINT expr
    (23) asgn_stmt -> . ID [ aexpr ] ASSIGN expr
    (24) asgn_stmt -> . ID ASSIGN expr
    {               shift and go to state 69
    FOR             shift and go to state 22
    WHILE           shift and go to state 23
    IF              shift and go to state 24
    RETURN          shift and go to state 25
    PRINT           shift and go to state 26
    ID              shift and go to state 27

    stmt                           shift and go to state 150
    block                          shift and go to state 67
    free_stmt                      shift and go to state 68
    compound_stmt                  shift and go to state 14
    simple_stmt                    shift and go to state 15
    for_stmt                       shift and go to state 16
    while_stmt                     shift and go to state 17
    if_stmt                        shift and go to state 18
    return_stmt                    shift and go to state 19
    print_stmt                     shift and go to state 20
    asgn_stmt                      shift and go to state 21

state 150

    (36) for_stmt -> FOR ( for_asgn ; for_lexpr ; for_asgn ) stmt .
    FOR             reduce using rule 36 (for_stmt -> FOR ( for_asgn ; for_lexpr ; for_asgn ) stmt .)
    WHILE           reduce using rule 36 (for_stmt -> FOR ( for_asgn ; for_lexpr ; for_asgn ) stmt .)
    IF              reduce using rule 36 (for_stmt -> FOR ( for_asgn ; for_lexpr ; for_asgn ) stmt .)
    RETURN          reduce using rule 36 (for_stmt -> FOR ( for_asgn ; for_lexpr ; for_asgn ) stmt .)
    PRINT           reduce using rule 36 (for_stmt -> FOR ( for_asgn ; for_lexpr ; for_asgn ) stmt .)
    ID              reduce using rule 36 (for_stmt -> FOR ( for_asgn ; for_lexpr ; for_asgn ) stmt .)
    $end            reduce using rule 36 (for_stmt -> FOR ( for_asgn ; for_lexpr ; for_asgn ) stmt .)
    ELSE            reduce using rule 36 (for_stmt -> FOR ( for_asgn ; for_lexpr ; for_asgn ) stmt .)
    }               reduce using rule 36 (for_stmt -> FOR ( for_asgn ; for_lexpr ; for_asgn ) stmt .)


Conflicts:

shift/reduce conflict for ELSE in state 90 resolved as shift